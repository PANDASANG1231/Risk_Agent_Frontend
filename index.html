<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Risk Agent - Advanced Financial Analysis</title>
    
    <!-- Local CSS -->
    <link href="./static/css/output.css" rel="stylesheet">
    
    <!-- Tailwind CSS CDN fallback -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- External Dependencies (Local files) -->
    <script src="./static/js/lucide.js"></script>
    <script src="./static/js/plotly.js"></script>
    <script src="./static/js/d3.min.js"></script>
    
    <!-- External Dependencies (CDN fallbacks) -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">

    <style>
        /* Details/Summary styling for collapsible sections */
        .transaction-details-toggle {
            border-radius: 12px;
            overflow: hidden;
        }
        
        .transaction-details-toggle summary {
            list-style: none;
            outline: none;
        }
        
        .transaction-details-toggle summary::-webkit-details-marker {
            display: none;
        }
        
        .transaction-details-toggle[open] .details-chevron {
            transform: rotate(180deg);
        }
        
        .transaction-details-toggle[open] summary {
            border-bottom: 1px solid #e5e7eb;
        }
        
        .details-chevron {
            transition: transform 0.2s ease;
        }
        
        /* Sortable table headers */
        th[data-sortable] {
            transition: background-color 0.2s ease;
        }
        
        th[data-sortable]:hover {
            background-color: #e5e7eb !important;
        }
        
        .sort-icon {
            margin-left: 4px;
            font-size: 10px;
            opacity: 0.7;
        }
        
        th[data-sort] .sort-icon {
            opacity: 1;
            font-weight: bold;
        }
        
        /* Modal scrollbar styling */
        .modal-scrollbar {
            scrollbar-width: thin;
            scrollbar-color: #cbd5e0 #f7fafc;
            overflow-y: scroll !important;
        }
        
        .modal-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        
        .modal-scrollbar::-webkit-scrollbar-track {
            background: #f7fafc;
            border-radius: 4px;
        }
        
        .modal-scrollbar::-webkit-scrollbar-thumb {
            background: #cbd5e0;
            border-radius: 4px;
        }
        
        .modal-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #a0aec0;
        }
        
        /* Force scrollbar to always show on webkit browsers */
        .modal-scrollbar::-webkit-scrollbar-thumb:window-inactive {
            background: #e2e8f0;
        }
        
        /* Horizontal Tab Styling */
        .horizontal-tab {
            display: inline-flex;
            align-items: center;
            padding: 0.5rem 1rem;
            margin-right: 0.5rem;
            border-radius: 8px;
            background-color: transparent;
            border: 1px solid transparent;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            white-space: nowrap;
            font-size: 0.875rem;
            font-weight: 500;
            color: #6b7280;
        }
        
        .horizontal-tab:hover {
            background-color: rgba(79, 70, 229, 0.08);
            color: #4f46e5;
            transform: translateY(-2px);
        }
        
        .horizontal-tab.active {
            background: linear-gradient(135deg, #4f46e5, #7c3aed);
            color: #fff;
            border-color: transparent;
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.3);
        }
        
        .horizontal-tab.active:hover {
            box-shadow: 0 6px 16px rgba(79, 70, 229, 0.4);
            transform: translateY(-3px);
        }
        
        .horizontal-tab .tab-icon {
            width: 1rem;
            height: 1rem;
            margin-right: 0.5rem;
            display: inline-flex;
        }
        
        /* Responsive positioning for horizontal nav */
        @media (min-width: 1024px) {
            #horizontal-nav {
                left: calc(16.666667% + 1rem) !important;
            }
        }
    </style>

</head>

<body class="min-h-screen antialiased">
    <!-- Progress Bar -->
    <div class="progress-bar fixed top-0 left-0 w-full z-50">
        <div class="progress-indicator w-0" id="progress-indicator"></div>
    </div>

    <!-- Scroll Indicator -->
    <div class="scroll-indicator" id="scroll-indicator"></div>

    <!-- Header -->
    <header class="glass fixed top-1 left-2 right-2 z-40 rounded-xl">
        <div class="px-4 py-2">
            <div class="flex items-center justify-between">
                                 <!-- Brand -->
                 <div class="flex items-center space-x-2">
                     <div class="w-8 h-8 bg-gradient-to-br from-primary-500 to-primary-700 rounded-lg flex items-center justify-center">
                         <i data-lucide="shield-check" class="w-4 h-4 text-white"></i>
                     </div>
                     <div>
                         <h1 class="text-lg font-bold text-gray-900">Risk Agent</h1>
                         <p class="text-xs text-gray-500">Advanced Financial Analysis</p>
                         <div id="account-status" class="text-xs text-gray-400 mt-1">
                             <!-- Account status will be displayed here -->
                         </div>
                     </div>
                 </div>

                                 <!-- Search & Actions -->
                 <div class="flex items-center space-x-2">
                     <!-- Account Selector -->
                     <div class="relative">
                         <select 
                             id="account-selector"
                             class="w-48 pl-8 pr-8 py-1.5 bg-gray-50 border border-gray-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent transition-all text-sm appearance-none cursor-pointer"
                         >
                             <option value="">Select Account...</option>
                         </select>
                         <i data-lucide="user" class="w-3 h-3 absolute left-2.5 top-1/2 transform -translate-y-1/2 text-gray-400"></i>
                         <i data-lucide="chevron-down" class="w-3 h-3 absolute right-2.5 top-1/2 transform -translate-y-1/2 text-gray-400 pointer-events-none"></i>
                     </div>

                     <!-- Actions -->
                     <button class="p-1.5 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors" id="refresh-btn">
                         <i data-lucide="refresh-cw" class="w-3 h-3 text-gray-600"></i>
                     </button>
                     
                    <button class="p-1.5 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors" id="export-btn">
                        <i data-lucide="download" class="w-3 h-3 text-gray-600"></i>
                    </button>
                    
                    <button class="p-1.5 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors" id="download-html-btn" title="Download HTML">
                        <i data-lucide="file-text" class="w-3 h-3 text-gray-600"></i>
                    </button>

                    <!-- Mobile Menu -->
                     <button class="lg:hidden p-1.5 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors" id="mobile-menu-toggle">
                         <i data-lucide="menu" class="w-3 h-3 text-gray-600"></i>
                     </button>
                 </div>
            </div>
        </div>
    </header>

    <!-- Horizontal Tab Navigation -->
    <nav class="fixed left-2 right-2 z-20 glass rounded-xl" id="horizontal-nav" style="top: 5.5rem;">
        <div class="flex items-center overflow-x-auto px-4 py-2 gap-1" id="horizontal-tab-container">
            <!-- Will be populated dynamically -->
        </div>
    </nav>

    <!-- Main Layout -->
    <div class="flex" style="padding-top: 8rem;">
        <!-- Sidebar -->
        <aside class="fixed left-2 bottom-2 w-1/6 glass rounded-xl p-3 z-30 transform -translate-x-full lg:translate-x-0 transition-transform duration-300" id="sidebar" style="top: 5.5rem;">
            <!-- Navigation -->
            <nav class="space-y-1" id="navigation">
                <!-- Will be populated dynamically -->
            </nav>
        </aside>

        <!-- Main Content -->
        <main class="flex-1 lg:ml-[calc(100vw/6+1rem)] p-6">
            <!-- Loading State -->
            <div class="loading-container hidden" id="loading-container">
                <div class="flex items-center justify-center h-64">
                    <div class="relative">
                        <div class="w-16 h-16 border-4 border-primary-200 border-t-primary-500 rounded-full animate-spin"></div>
                        <div class="absolute inset-0 flex items-center justify-center">
                            <i data-lucide="activity" class="w-6 h-6 text-primary-500"></i>
                    </div>
                            </div>
                        </div>
                <p class="text-center text-gray-600 mt-4">Loading risk analysis data...</p>
                        </div>

                                                 <!-- Content Sections -->
             <div id="content-container">
                                  <!-- Business Pattern Section -->
                  <section id="business-pattern" class="section-content">
                      <div class="section-header">
                          <h2 class="text-xl font-bold text-gray-900">Overall Summary</h2>
                          <p class="text-gray-600">Industry alignment</p>
                      </div>
                      <div class="card-elevated" id="business-pattern-content">
                          <!-- Will be populated dynamically -->
                      </div>
                  </section>

                 <!-- Transactions Section -->
                 <section id="transactions" class="section-content">
                     <div class="section-header">
                         <h2 class="text-xl font-bold text-gray-900">Transactions</h2>
                         <p class="text-gray-600">Transaction breakdown</p>
                     </div>
                     <div class="card-elevated" id="transactions-content">
                         <!-- Will be populated dynamically -->
                     </div>
                 </section>

                 <!-- Company Info Section -->
                 <section id="public-info" class="section-content">
                     <div class="section-header">
                         <h2 class="text-xl font-bold text-gray-900">Company Info</h2>
                         <p class="text-gray-600">Public information</p>
                     </div>
                     <div class="card-elevated" id="public-info-content">
                         <!-- Will be populated dynamically -->
                     </div>
                 </section>

                 <!-- Other sections will be added dynamically -->
                     </div>
            </main>
    </div>

    <!-- Mobile Overlay -->
    <div id="mobile-overlay" class="fixed inset-0 bg-black bg-opacity-50 z-20 hidden lg:hidden"></div>

    <!-- JavaScript -->
    <script>
        // Initialize Lucide icons
        const { createIcons } = window.lucide;
        createIcons();

                 // Global state
        let currentSection = 'business-pattern';
        let apiData = {};
        let selectedAccount = null;
        let availableAccounts = [];
        
                 // Navigation configuration
         const sections = [
             { id: 'business-pattern', name: 'Overall Summary', icon: 'bar-chart-3', description: 'Industry alignment' },
             { id: 'transactions', name: 'Transactions', icon: 'trending-up', description: 'Transaction breakdown' },
             { id: 'public-info', name: 'Company Info', icon: 'building', description: 'Public information' },
             { id: 'high-cash', name: 'Internal Analysis', icon: 'dollar-sign', description: 'Previous existing analysis' }
         ];

        // Utility functions
        function formatCurrency(amount) {
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: 0,
                maximumFractionDigits: 0
            }).format(amount);
        }

        function formatNumber(num) {
            return new Intl.NumberFormat('en-US').format(num);
        }

        // API functions
        async function fetchApiData(endpoint, acctno = null) {
            try {
                let url = `/api/${endpoint}`;
                if (acctno) {
                    url += `?acctno=${encodeURIComponent(acctno)}`;
                }
                
                console.log(`Fetching data from ${url}...`);
                const response = await fetch(url);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`HTTP ${response.status} for ${endpoint}:`, errorText);
                    throw new Error(`Failed to fetch ${endpoint}: ${response.status} - ${errorText}`);
                }
                
                const data = await response.json();
                console.log(`Successfully fetched ${endpoint}:`, data);
                return data;
            } catch (error) {
                console.error(`Error fetching ${endpoint}:`, error);
                // Return empty object instead of throwing to prevent dashboard failure
                return {};
            }
        }

        // Load available accounts
        async function loadAvailableAccounts() {
            try {
                console.log('Loading available accounts...');
                const accountsData = await fetchApiData('accounts');
                
                if (accountsData && accountsData.accounts) {
                    availableAccounts = accountsData.accounts;
                    console.log('Available accounts:', availableAccounts);
                    
                    // Populate account selector
                    const accountSelector = document.getElementById('account-selector');
                    accountSelector.innerHTML = '<option value="">Select Account...</option>';
                    
                    availableAccounts.forEach(acctno => {
                        const option = document.createElement('option');
                        option.value = acctno;
                        option.textContent = `Account ${acctno}`;
                        accountSelector.appendChild(option);
                    });
                    
                    // If there's only one account, auto-select it
                    if (availableAccounts.length === 1) {
                        accountSelector.value = availableAccounts[0];
                        selectedAccount = availableAccounts[0];
                        await loadAccountData(selectedAccount);
                    }
                } else {
                    console.warn('No accounts found or invalid response format');
                }
            } catch (error) {
                console.error('Error loading accounts:', error);
                showError('Failed to load available accounts. Please check if the server is running.');
            }
        }

        // Load data for a specific account
        async function loadAccountData(acctno) {
            if (!acctno) {
                console.warn('No account number provided');
                return;
            }
            
            selectedAccount = acctno;
            console.log(`Loading data for account: ${acctno}`);
            
            // Show loading state
            const loadingContainer = document.getElementById('loading-container');
            loadingContainer.classList.remove('hidden');
            
            try {
                // Fetch all data for the selected account
                console.log('Fetching data from all API endpoints for account:', acctno);
                const [
                    transactionsData,
                    businessPatternData,
                    publicInfoData,
                    publicAddressData,
                    customerInfoData,
                    moneyFlowData,
                    moneyUsageData,
                    transUsageDictData,
                    transUsageDetailDictData,
                    graphData,
                    utrInfoData
                ] = await Promise.all([
                    fetchApiData('transactions', acctno),
                    fetchApiData('business-pattern', acctno),
                    fetchApiData('public-info', acctno),
                    fetchApiData('public-address', acctno),
                    fetchApiData('customer-info', acctno),
                    fetchApiData('money-flow', acctno),
                    fetchApiData('money-usage', acctno),
                    fetchApiData('transactions_usage_dict', acctno),
                    fetchApiData('transactions_usage_detail_dict', acctno),
                    fetchApiData('graph', acctno),
                    fetchApiData('utr-info', acctno)
                ]);

                // Store data globally
                apiData = {
                    transactions: transactionsData,
                    businessPattern: businessPatternData,
                    publicInfo: publicInfoData,
                    publicAddress: publicAddressData,
                    customerInfo: customerInfoData,
                    moneyFlow: moneyFlowData,
                    moneyUsage: moneyUsageData,
                    transUsageDict: transUsageDictData,
                    transUsageDetailDict: transUsageDetailDictData,
                    graph: graphData,
                    utrInfo: utrInfoData
                };

                console.log('Stored apiData for account:', acctno, apiData);

                // Update UI with new data
                updateDashboardWithAccountData();
                
                // Update horizontal tabs for related accounts
                await createHorizontalTabs();
                
            } catch (error) {
                console.error('Error loading account data:', error);
                showError(`Failed to load data for account ${acctno}: ${error.message}`);
            } finally {
                loadingContainer.classList.add('hidden');
            }
        }

        // Update dashboard with account data
        function updateDashboardWithAccountData() {
            // Update account status
            updateAccountStatus();
            
            // Create UI components
            createNavigation();
            
            // Update transactions section if data exists
            if (apiData.transactions && Object.keys(apiData.transactions).length > 0) {
                createTransactionsSankey(apiData.transactions);
                createKeyMetrics(apiData.transactions);
            }
            
            // Update business-pattern section content
            const businessPatternContainer = document.getElementById('business-pattern-content');
            if (businessPatternContainer) {
                businessPatternContainer.innerHTML = createBusinessPatternContent();
            }
            
            // Update public-info section content
            const publicInfoContainer = document.getElementById('public-info-content');
            if (publicInfoContainer) {
                publicInfoContainer.innerHTML = createPublicInfoContent();
            }
            
            // Create other sections
            sections.forEach(section => {
                if (section.id !== 'transactions' && section.id !== 'public-info' && section.id !== 'business-pattern') {
                    createSection(section.id);
                }
            });
            
            // Render network graph if data is available
            if (apiData.graph && apiData.graph.nodes && apiData.graph.nodes.length > 0) {
                console.log('Graph data available, scheduling render:', apiData.graph);
                setTimeout(async () => {
                    console.log('Attempting to render network graph...');
                    // Check if container exists and has dimensions before rendering
                    const container = document.getElementById('network-graph');
                    if (container && container.offsetWidth > 0 && container.offsetHeight > 0) {
                        await renderNetworkGraph();
                    } else {
                        console.log('Container not ready, retrying in 100ms...');
                        setTimeout(async () => await renderNetworkGraph(), 100);
                    }
                }, 500); // Increased timeout to ensure DOM is ready
            } else {
                console.log('No graph data available:', apiData.graph);
            }
            
            // Populate transaction usage detail content
            populateTransactionUsageDetail();
            
            // Show business pattern as default
            showSection('business-pattern');
            
            // Set up scroll sync
            setupScrollSync();
        }

        // Update account status display
        function updateAccountStatus() {
            const accountStatus = document.getElementById('account-status');
            if (selectedAccount) {
                accountStatus.innerHTML = `
                    <span class="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
                        <i data-lucide="check-circle" class="w-3 h-3 mr-1"></i>
                        Account ${selectedAccount} Selected
                    </span>
                `;
            } else {
                accountStatus.innerHTML = `
                    <span class="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-600">
                        <i data-lucide="user" class="w-3 h-3 mr-1"></i>
                        No Account Selected
                    </span>
                `;
            }
            createIcons();
        }



        // Create navigation
        function createNavigation() {
            const nav = document.getElementById('navigation');
            nav.innerHTML = sections.map(section => `
                <button 
                    class="nav-item w-full flex items-center p-2 rounded-lg text-left transition-all group"
                    data-section="${section.id}"
                    onclick="showSection('${section.id}')"
                >
                    <div class="w-6 h-6 bg-gray-100 group-hover:bg-primary-100 rounded-md flex items-center justify-center mr-2 transition-colors">
                        <i data-lucide="${section.icon}" class="w-3 h-3 text-gray-600 group-hover:text-primary-600"></i>
                    </div>
                    <div class="flex-1">
                        <div class="font-medium text-gray-900 group-hover:text-white text-xs">${section.name}</div>
                        <div class="text-xs text-gray-500 group-hover:text-gray-200">${section.description}</div>
                    </div>
                    <i data-lucide="chevron-right" class="w-3 h-3 text-gray-400 group-hover:text-white opacity-0 group-hover:opacity-100 transition-all"></i>
                </button>
            `).join('');
            
            createIcons();
        }

                 // Show section and scroll to it
         function showSection(sectionId) {
             currentSection = sectionId;
             
             // Update navigation
             document.querySelectorAll('.nav-item').forEach(item => {
                 item.classList.toggle('active', item.dataset.section === sectionId);
             });

             // Update horizontal tabs
             document.querySelectorAll('.horizontal-tab').forEach(item => {
                 item.classList.toggle('active', item.dataset.section === sectionId);
             });

             // Create section if it doesn't exist
             if (!document.getElementById(sectionId) && sectionId !== 'transactions' && sectionId !== 'public-info' && sectionId !== 'business-pattern') {
                 createSection(sectionId);
             }
             
             // Add smooth transition effects
             document.querySelectorAll('.section-content').forEach(section => {
                 section.style.opacity = '0.7';
                 section.style.transform = 'scale(0.98)';
             });
             
             // Highlight the target section
             const targetSection = document.getElementById(sectionId);
             if (targetSection) {
                 setTimeout(() => {
                     targetSection.style.opacity = '1';
                     targetSection.style.transform = 'scale(1)';
                     targetSection.classList.add('fade-in');
                     
                     // Remove fade-in class after animation
                     setTimeout(() => {
                         targetSection.classList.remove('fade-in');
                     }, 500);
                 }, 100);
                 
                 targetSection.scrollIntoView({ 
                     behavior: 'smooth', 
                     block: 'start' 
                 });
             }
             
             // Update progress
             updateProgress();
             
             // Special handling for transactions section
             if (sectionId === 'transactions') {
                 setTimeout(() => {
                     const chart = document.getElementById('sankey-chart');
                     if (chart && chart.data) {
                         Plotly.Plots.resize(chart);
                     }
                 }, 100);
             }
             
             // Close mobile menu
             if (window.innerWidth < 1024) {
                 toggleMobileMenu(false);
             }
         }

        // Update active navigation based on scroll position
        function updateActiveNavigation() {
            const sections = document.querySelectorAll('.section-content');
            const navItems = document.querySelectorAll('.nav-item');
            const horizontalTabs = document.querySelectorAll('.horizontal-tab');
            
                         let currentActiveSection = 'business-pattern';
            
            // Simple approach: find the section that's most visible in the viewport
            sections.forEach(section => {
                const rect = section.getBoundingClientRect();
                const sectionTop = rect.top;
                const sectionHeight = rect.height;
                
                // If section is mostly visible in the viewport, make it active
                if (sectionTop <= 100 && sectionTop + sectionHeight > 100) {
                    currentActiveSection = section.id;
                }
            });
            
            // Update navigation active state
            navItems.forEach(item => {
                item.classList.toggle('active', item.dataset.section === currentActiveSection);
            });
            
            // Update horizontal tabs active state
            horizontalTabs.forEach(item => {
                item.classList.toggle('active', item.dataset.section === currentActiveSection);
            });
            
            // Update current section
            if (currentActiveSection !== currentSection) {
                currentSection = currentActiveSection;
            }
            
            // Update scroll indicator
            updateScrollIndicator();
        }

        // Update scroll indicator width
        function updateScrollIndicator() {
            const scrollIndicator = document.getElementById('scroll-indicator');
            if (scrollIndicator) {
                const mainElement = document.querySelector('main');
                const scrollTop = mainElement.scrollTop;
                const scrollHeight = mainElement.scrollHeight - mainElement.clientHeight;
                const scrollPercentage = scrollHeight > 0 ? (scrollTop / scrollHeight) * 100 : 0;
                scrollIndicator.style.width = `${scrollPercentage}%`;
            }
        }

                // Create section dynamically
        function createSection(sectionId) {
            const container = document.getElementById('content-container');
            const sectionConfig = sections.find(s => s.id === sectionId);
            
            // Check if section already exists and remove it first
            const existingSection = document.getElementById(sectionId);
            if (existingSection) {
                existingSection.remove();
            }
            
            const sectionElement = document.createElement('section');
            sectionElement.id = sectionId;
            sectionElement.className = 'section-content';
            
            // Special handling for high-cash section
            if (sectionId === 'high-cash') {
                sectionElement.innerHTML = `
                    <div class="section-header">
                        <h2 class="text-xl font-bold text-gray-900">${sectionConfig.name}</h2>
                        <p class="text-gray-600">${sectionConfig.description}</p>
                    </div>
                    <div class="card-elevated" id="${sectionId}-content">
                        ${createHighCashContent()}
                    </div>
                `;
            } else if (sectionId === 'business-pattern') {
                sectionElement.innerHTML = `
                    <div class="section-header">
                        <h2 class="text-xl font-bold text-gray-900">${sectionConfig.name}</h2>
                        <p class="text-gray-600">${sectionConfig.description}</p>
                    </div>
                    <div class="card-elevated" id="${sectionId}-content">
                        ${createBusinessPatternContent()}
                    </div>
                `;
            } else {
                sectionElement.innerHTML = `
                    <div class="section-header">
                        <h2 class="text-xl font-bold text-gray-900">${sectionConfig.name}</h2>
                        <p class="text-gray-600">${sectionConfig.description}</p>
                    </div>
                    <div class="card-elevated" id="${sectionId}-content">
                        <div class="text-center">
                            <div class="w-12 h-12 bg-primary-100 rounded-lg flex items-center justify-center mx-auto mb-2">
                                <i data-lucide="${sectionConfig.icon}" class="w-6 h-6 text-primary-600"></i>
                            </div>
                            <p class="text-xs text-gray-600">Loading ${sectionConfig.name.toLowerCase()} data...</p>
                        </div>
                    </div>
                `;
            }
            
            container.appendChild(sectionElement);
            createIcons();
            
            // Set up checkbox event listener if this is the high-cash section
            if (sectionId === 'high-cash') {
                setupShowFullGraphCheckbox();
            }
        }

                 // Create high cash content
         function createHighCashContent() {
             return `
                <!-- UTR Information Section -->
                <div class="mt-4">
                    <div class="bg-white rounded-lg p-4 border border-gray-200 mb-4">
                        <!-- Table -->
                        <div style="height: 200px; overflow-y: auto; border: 1px solid #e5e7eb; border-radius: 6px;">
                            ${createUTRTable()}
                        </div>
                    </div>
                </div>

                <!-- Network Visualization Section -->
                <div class="mt-4">
                    <div class="flex items-center gap-4 mb-2">
                        <h4 class="text-base font-semibold text-gray-900">Linkage analysis</h4>
                        <div class="flex items-center radio-group-spacing">
                            <label class="flex items-center space-x-1 cursor-pointer mr-12">
                                <input type="radio" id="show-full-graph" name="graph-view" value="full" class="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 focus:ring-blue-500 focus:ring-2">
                                <span class="text-sm text-gray-600">&nbsp;Full Graph&nbsp&nbsp;&nbsp;&nbsp;&nbsp;</span>
                            </label>
                            <label class="flex items-center space-x-1 cursor-pointer mr-12">
                                <input type="radio" id="show-tree" name="graph-view" value="tree" class="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 focus:ring-blue-500 focus:ring-2">
                                <span class="text-sm text-gray-600">&nbsp;Tree&nbsp&nbsp;&nbsp;&nbsp;&nbsp;</span>
                            </label>
                            <label class="flex items-center space-x-1 cursor-pointer mr-4">
                                <input type="radio" id="show-subgraph" name="graph-view" value="subgraph" class="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 focus:ring-blue-500 focus:ring-2" checked>
                                <span class="text-sm text-gray-600">&nbsp;Subgraph,&nbsp;</span>
                            </label>
                            <div class="flex items-center space-x-2">
                                <label class="text-xs text-gray-600">Degree:</label>
                                <select id="subgraph-degree" class="text-xs border border-gray-300 rounded px-2 py-1 bg-white">
                                    <option value="1">1</option>
                                    <option value="2" selected>2</option>
                                    <option value="3">3</option>
                                    <option value="4">4</option>
                                    <option value="5">5</option>
                                    <option value="6">6</option>
                                    <option value="7">7</option>
                                    <option value="8">8</option>
                                    <option value="9">9</option>
                                    <option value="10">10</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="w-full" style="height: 480px;">
                        <div class="bg-white rounded-lg p-2 h-full border border-gray-200">
                            <div class="h-full">
                                ${createNetworkVisualization()}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

                 

        // Create network visualization
        function createNetworkVisualization() {
            console.log('createNetworkVisualization called with apiData.graph:', apiData.graph);
            
            if (!apiData.graph) {
                console.log('No graph data in apiData');
                return `
                    <div class="text-center">
                        <div class="w-12 h-12 bg-purple-100 rounded-lg flex items-center justify-center mx-auto mb-2">
                            <i data-lucide="network" class="w-6 h-6 text-purple-600"></i>
                        </div>
                        <p class="text-xs text-gray-600">Loading network graph data...</p>
                    </div>
                `;
            }

            // Check if graph data has content
            if (!apiData.graph.nodes || !apiData.graph.links || apiData.graph.nodes.length === 0) {
                console.log('Graph data incomplete:', {
                    hasNodes: !!apiData.graph.nodes,
                    hasLinks: !!apiData.graph.links,
                    nodesLength: apiData.graph.nodes?.length
                });
                return `
                    <div class="text-center py-4 text-gray-500">
                        <i data-lucide="network" class="w-8 h-8 mx-auto mb-2 text-gray-300"></i>
                        <p>No network graph data available</p>
                    </div>
                `;
            }

            return `
                <div class="space-y-4">
                    <!-- Graph Statistics Title -->
                    <div class="text-left">
                        <div class="text-base text-gray-700 font-medium" id="graph-stats">
                            Loading graph statistics...
                        </div>
                    </div>
                    
                    <!-- Network Graph Container -->
                    <div id="network-graph" style="height: 400px; width: 100%; min-height: 320px; min-width: 400px; border: 1px solid #e5e7eb; border-radius: 8px; resize: both; overflow: hidden; margin: 0; background-color: white; position: relative;">
                        <div class="absolute inset-0 flex items-center justify-center text-gray-500">
                            <div class="text-center">
                                <i data-lucide="network" class="w-8 h-8 mx-auto mb-2 text-gray-300"></i>
                                <p>Network graph will render here</p>
                                <p class="text-xs">Click "Render Graph" button to start</p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Render Button and Legend -->
                    <div class="flex items-center justify-start space-x-6 mt-3">
                        <button onclick="renderNetworkGraph()" class="px-3 py-1 bg-blue-500 text-white text-xs rounded hover:bg-blue-600">
                            <i data-lucide="refresh-cw" class="w-3 h-3 inline mr-1"></i>Render Graph
                        </button>
                        
                        <!-- Legend -->
                        <div class="text-xs text-gray-600">
                            <div class="flex flex-wrap gap-4">
                                ${createNodeTypeLegend()}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Create node type legend (limited to 4 types)
        function createNodeTypeLegend() {
            if (!apiData.graph || !apiData.graph.nodes) return '';
            
            const nodeTypes = {};
            apiData.graph.nodes.forEach(node => {
                if (node.node_type && node.color) {
                    nodeTypes[node.node_type] = node.color;
                }
            });
            
            // Limit to only 4 node types
            const limitedTypes = Object.entries(nodeTypes).slice(0, 4);
            
            return limitedTypes.map(([type, color]) => `
                <div class="flex items-center space-x-2">
                    <div class="w-3 h-3 rounded-full" style="background-color: ${color};"></div>
                    <span>${type}</span>
                </div>
            `).join('');
        }

        // Fetch formatted account number from customer-info API
        async function getFormattedAccountNumber(acctno) {
            try {
                console.log(`Fetching formatted account number for: ${acctno}`);
                const response = await fetch(`/api/customer-info?acctno=${encodeURIComponent(acctno)}`);
                
                if (!response.ok) {
                    console.error(`HTTP ${response.status} for customer-info:`, await response.text());
                    return acctno; // Fallback to original account number
                }
                
                const data = await response.json();
                if (data && data.frmtd_acct_no) {
                    const frmtdAcctno = String(data.frmtd_acct_no).padStart(16, '0');
                    console.log(`Formatted account number: ${acctno} -> ${frmtdAcctno}`);
                    return frmtdAcctno;
                } else {
                    console.warn('No frmtd_acct_no found in customer-info response');
                    return acctno; // Fallback to original account number
                }
            } catch (error) {
                console.error(`Error fetching formatted account number:`, error);
                return acctno; // Fallback to original account number
            }
        }

        // Get subgraph data from API (selected account + direct neighbors)
        async function getSubgraphData() {
            // If no account is selected, try to get the target account from customer info
            let targetAccount = selectedAccount;
            if (!targetAccount && apiData.customerInfo && apiData.customerInfo.frmtd_acct_no) {
                targetAccount = String(apiData.customerInfo.frmtd_acct_no).padStart(16, '0');
                console.log(`No account selected, using target account from customer info: ${targetAccount}`);
            }
            
            if (!targetAccount) {
                console.warn('No account selected and no target account found in customer info, showing full graph instead of subgraph');
                return apiData.graph;
            }
            
            try {
                console.log(`Fetching subgraph data from API for account: ${targetAccount}`);
                                
                // Get formatted account number if we have a selected account
                let centerNode = apiData.customerInfo.frmtd_acct_no;
            if (selectedAccount) {
                    centerNode = await getFormattedAccountNumber(selectedAccount);
                    console.log(`Using formatted account number for subgraph: ${centerNode}`);
            } else {
                    console.log(`Using target account directly: ${centerNode}`);
                }
                
                // Get the degree value from the dropdown
                const degreeDropdown = document.getElementById('subgraph-degree');
                const degree = degreeDropdown ? degreeDropdown.value : '2';
                
                // Call the new subgraph API endpoint
                const response = await fetch(`/api/subgraph?acctno=${selectedAccount}&center_node=${encodeURIComponent(centerNode)}&degree=${degree}`);
                
                if (!response.ok) {
                    console.error(`HTTP ${response.status} for subgraph API:`, await response.text());
                    // Fallback to full graph
                return apiData.graph;
            }
            
                const subgraphData = await response.json();
                console.log('Subgraph data received from API:', {
                    nodes: subgraphData.nodes?.length || 0,
                    links: subgraphData.links?.length || 0,
                    centerNode: subgraphData.center_node,
                    degree: subgraphData.degree
                });
                
                // Return the true subgraph data (not full graph with visibility flags)
            return {
                    nodes: subgraphData.nodes || [],
                    links: subgraphData.links || [],
                    centerNode: subgraphData.center_node,
                    degree: subgraphData.degree,
                    isSubgraph: true // Flag to indicate this is a true subgraph
                };
                
            } catch (error) {
                console.error('Error fetching subgraph data:', error);
                // Fallback to full graph
                return apiData.graph;
            }
        }

        // Render network graph using D3.js
        async function renderTreeGraph() {
            console.log('renderTreeGraph called');
            
            // Try to use existing graph data first, then fetch tree data if needed
            let treeSourceData = apiData.graph;
            
            // If no graph data, fetch tree data from API
            if (!treeSourceData || !treeSourceData.nodes || !treeSourceData.links) {
                try {
                    console.log('Fetching tree data from API...');
                    const acctno = new URLSearchParams(window.location.search).get('acctno') || '12345';
                    const response = await fetch(`/api/tree?acctno=${acctno}`);
                    const treeData = await response.json();
                    
                    if (response.ok && treeData.nodes && treeData.links) {
                        treeSourceData = treeData;
                        apiData.tree = treeData;
                        console.log('Tree data loaded:', treeData);
                    } else {
                        console.error('Failed to load tree data or invalid data structure:', treeData);
                        return;
                    }
                } catch (error) {
                    console.error('Error fetching tree data:', error);
                    return;
                }
            }
            
            console.log('Tree source data:', treeSourceData);
            
            const container = document.getElementById('network-graph');
            if (!container) {
                console.warn('Network graph container not found');
                return;
            }
            
            // Check if container has proper dimensions
            if (container.offsetWidth === 0 || container.offsetHeight === 0) {
                console.warn('Container has no dimensions, retrying in 100ms...');
                setTimeout(() => renderTreeGraph(), 100);
                return;
            }
            
            // Clear previous content
            container.innerHTML = '';
            
            const width = container.offsetWidth;
            const height = container.offsetHeight;
            
            console.log('Tree container dimensions:', { width, height });
            
            // Create SVG
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);
                
            window.currentSvg = svg.node();
                window.currentGraphData = null; // Tree mode doesn't have subgraph data
            
            // Create a group for zoom/pan
            const g = svg.append('g');
            
            // Convert graph data to tree structure
            const conversionResult = convertGraphToTree(treeSourceData);
            
            if (!conversionResult || !conversionResult.tree) {
                console.warn('Could not convert graph data to tree structure');
                console.log('Trying simple test tree structure...');
                
                // Create a simple test tree structure
                const testTreeData = {};
                
                console.log('Using test tree data:', testTreeData);
                // Use test data instead of returning
                const treeDataToUse = testTreeData;
            } else {
                const treeDataToUse = conversionResult.tree;
            }
            
            // Extract tree data and link colors
            const treeData = conversionResult ? conversionResult.tree : null;
            const linkColors = conversionResult ? conversionResult.linkColors : new Map();
            
            // Use the determined tree data
            const finalTreeData = treeData || {
                id: 'root',
                label: 'Root Node',
                color: '#ff6b6b',
                isRoot: true,
                children: [
                    {
                        id: 'child1',
                        label: 'Child 1',
                        color: '#69b3a2',
                        isRoot: false,
                        children: []
                    }
                ]
            };
            
            // Create hierarchy from tree data
            console.log('Creating D3 hierarchy from tree data:', finalTreeData);
            
            let root;
            try {
                root = d3.hierarchy(finalTreeData);
                
                // Calculate tree dimensions based on hierarchy
                const treeDepth = root.height;
                const treeWidth = root.descendants().length;
                
                console.log(`Tree structure: depth=${treeDepth}, nodes=${treeWidth}`);
                console.log('Root node:', root);
                console.log('All descendants:', root.descendants());
                
                if (treeWidth === 0) {
                    console.error('No nodes found in tree hierarchy');
                    container.innerHTML = '<div class="flex items-center justify-center h-full"><p class="text-red-500">Tree has no nodes to display</p></div>';
                    return;
                }
            } catch (error) {
                console.error('Error creating D3 hierarchy:', error);
                container.innerHTML = '<div class="flex items-center justify-center h-full"><p class="text-red-500">Error creating tree hierarchy: ' + error.message + '</p></div>';
                return;
            }
            
            // Create D3 force-directed tree layout using physics simulation
            console.log('Creating force-directed tree layout');
            
            // Compute the graph structure from hierarchy
            const links = root.links();
            const nodes = root.descendants();
            
            console.log('Force simulation data:', { nodes: nodes.length, links: links.length });
            
            // Set up SVG with proper viewBox and styling
            svg.attr("viewBox", [-width / 2, -height / 2, width, height])
               .attr("style", "max-width: 100%; height: auto; font: 10px sans-serif;");
            
            // Create force simulation
            const simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id).distance(72).strength(0.65))
                .force("charge", d3.forceManyBody().strength(-180))
                .force("center", d3.forceCenter(0, 0))
                .force("collision", d3.forceCollide().radius(32));
            
            // Create links group
            const linksGroup = g.append("g")
                .attr("stroke", "#999")
                .attr("stroke-opacity", 0.3);
            
            // Add links
            const linkElements = linksGroup
                .selectAll("line")
                .data(links)
                .join("line")
                .attr("class", "tree-link")
                .attr("stroke", d => {
                    // Create link key from source and target IDs
                    const sourceId = d.source.data.id.toString();
                    const targetId = d.target.data.id.toString();
                    const linkKey = `${sourceId}-${targetId}`;
                    return linkColors.get(linkKey) || linkColors.get(`${targetId}-${sourceId}`) || '#999';
                })
                .attr("stroke-width", 1.5);
            
            console.log('Created', linkElements.size(), 'force-directed links');
            
            // Create link labels (relationship text) - hidden by default
            const linkLabelsGroup = g.append("g");
            const linkLabels = linkLabelsGroup
                .selectAll("text")
                .data(links)
                .join("text")
                .attr("class", "link-label")
                .attr("font-size", "10px")
                .attr("font-weight", "bold")
                .attr("fill", d => {
                    // Get relationship color from linkColors map
                    const sourceId = d.source.data.id.toString();
                    const targetId = d.target.data.id.toString();
                    const linkKey = `${sourceId}-${targetId}`;
                    return linkColors.get(linkKey) || linkColors.get(`${targetId}-${sourceId}`) || '#999';
                })
                .attr("text-anchor", "middle")
                .attr("pointer-events", "none")
                .attr("opacity", 0) // Hidden by default
                .text(d => {
                    // Get relationship from original graph data
                    const sourceId = d.source.data.id.toString();
                    const targetId = d.target.data.id.toString();
                    
                    // Find the relationship in original graph data
                    if (treeSourceData && treeSourceData.links) {
                        const originalLink = treeSourceData.links.find(link => {
                            const origSourceId = (typeof link.source === 'object') ? link.source.id.toString() : link.source.toString();
                            const origTargetId = (typeof link.target === 'object') ? link.target.id.toString() : link.target.toString();
                            return (origSourceId === sourceId && origTargetId === targetId) || 
                                   (origSourceId === targetId && origTargetId === sourceId);
                        });
                        return originalLink ? originalLink.relationship : '';
                    }
                    return '';
                });
            
            console.log('Created', linkLabels.size(), 'force-directed link labels');
            
            // Create nodes group
            const nodesGroup = g.append("g")
                .attr("fill", "#fff")
                .attr("stroke", "#000")
                .attr("stroke-width", 1.5);
            
            // Add node circles
            const nodeCircles = nodesGroup
                .selectAll("circle")
                .data(nodes)
                .join("circle")
                .attr("class", "tree-node")
                .attr("fill", d => d.data.color || "#69b3a2")
                .attr("stroke", d => d.data.isRoot ? d.data.color || "#69b3a2" : "#333")
                .attr("r", 12)
                .attr("opacity", 0.8)
                .style('cursor', 'pointer')
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));
            
            console.log('Created', nodeCircles.size(), 'force-directed nodes');
            
            // Add tooltips to nodes
            nodeCircles.append("title")
                .text(d => d.data.label || d.data.id);
            
            // Add labels group
            const labelsGroup = g.append("g")
                .attr("stroke-linejoin", "round")
                .attr("stroke-width", 2);
            
            // Add labels
            const nodeLabels = labelsGroup
                .selectAll("text")
                .data(nodes)
                .join("text")
                .attr("class", "tree-label")
                .attr("dy", "0.31em")
                .attr("text-anchor", "middle")
                .attr("fill", "currentColor")
                .style("font-size", "10px")
                .style("font-weight", "bold")
                .style("pointer-events", "none")
                .text(d => d.data.label || d.data.id);
            
            console.log('Created', nodeLabels.size(), 'force-directed labels');
            
            // Set up simulation tick handler
            simulation.on("tick", () => {
                // Update link positions
                linkElements
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);
                
                // Update link label positions (center of each link)
                linkLabels
                    .attr("x", d => (d.source.x + d.target.x) / 2)
                    .attr("y", d => (d.source.y + d.target.y) / 2);
                
                // Update node positions
                nodeCircles
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);
                
                // Update label positions
                nodeLabels
                    .attr("x", d => d.x)
                    .attr("y", d => d.y);
            });
            
            // Drag functions for interactive node movement
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            
            console.log('Force simulation initialized and running');
            
            // Add interactive behaviors to node circles
            nodeCircles
                // Hover effects
                .on('mouseover', function(event, d) {
                    console.log('Node hovered:', d.data.label || d.data.id);
                    
                    // Enlarge the hovered node
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr('r', 18)
                        .attr('stroke-width', 3);
                    
                    // Highlight connected edges and relationships
                    highlightNodeConnections(d);
                    
                })
                .on('mouseout', function(event, d) {
                    // Reset node size and appearance
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr('r', 12)
                        .attr('stroke-width', 1.5);
                    
                    // Reset all highlighting
                    resetHighlighting();
                    
                })
                
                // Click effects
                .on('click', function(event, d) {
                    console.log('Node clicked:', d.data.label || d.data.id);
                    
                    // For force-directed layout, just show details
                    showNodeDetails(d);
                    
                    // Prevent event bubbling
                    event.stopPropagation();
                });
            
            // Store simulation reference for cleanup
            window.currentSimulation = simulation;
            
            // Add zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', function(event) {
                    g.attr('transform', event.transform);
                });
            
            svg.call(zoom);
            
            console.log('Interactive radial tree rendered successfully');
            console.log('Final SVG element:', svg.node());
            console.log('SVG children count:', svg.node().children.length);
            console.log('Container final state:', container);
            
            // Update tree statistics display
            updateTreeStatistics(nodes.length, links.length);
            
            // Store references for interactive functions
            window.currentTreeData = {
                svg: svg,
                g: g,
                linkElements: linkElements,
                nodeCircles: nodeCircles,
                nodeLabels: nodeLabels,
                nodes: nodes,
                links: links,
                simulation: simulation
            };
            
            // Update tables to show only entries for current tree nodes
            updateTablesForCurrentGraph(treeSourceData);
        }

        // Update tree statistics display
        function updateTreeStatistics(nodeCount, linkCount) {
            const statsElement = document.getElementById('graph-stats');
            if (statsElement) {
                statsElement.textContent = `The tree has ${nodeCount} nodes and ${linkCount} linkages`;
            }
        }

        
        function convertGraphToTree(graphData) {
            console.log('Converting graph to tree, input data:', graphData);
            
            if (!graphData || !graphData.nodes || !graphData.links) {
                console.error('Invalid graph data for tree conversion:', graphData);
                return null;
            }
            
            if (graphData.nodes.length === 0) {
                console.error('No nodes in graph data');
                return null;
            }
            
            console.log(`Graph has ${graphData.nodes.length} nodes and ${graphData.links.length} links`);
            
            // Find root node (could be the target account or most connected node)
            let rootNode = null;
            
            // Try to find customer account as root
            if (apiData.customerInfo && apiData.customerInfo.frmtd_acct_no) {
                const targetAccount = apiData.customerInfo.frmtd_acct_no.toString();
                rootNode = graphData.nodes.find(node => node.id.toString() === targetAccount);
                console.log('Looking for customer account as root:', targetAccount, 'Found:', !!rootNode);
            }
            
            // If no customer account, find most connected node
            if (!rootNode) {
                console.log('No customer account found, finding most connected node...');
                const nodeDegrees = {};
                
                // Handle both object and string formats for source/target
                graphData.links.forEach(link => {
                    const sourceId = (typeof link.source === 'object') ? link.source.id : link.source;
                    const targetId = (typeof link.target === 'object') ? link.target.id : link.target;
                    
                    nodeDegrees[sourceId] = (nodeDegrees[sourceId] || 0) + 1;
                    nodeDegrees[targetId] = (nodeDegrees[targetId] || 0) + 1;
                });
                
                console.log('Node degrees:', nodeDegrees);
                
                let maxDegree = 0;
                Object.keys(nodeDegrees).forEach(nodeId => {
                    if (nodeDegrees[nodeId] > maxDegree) {
                        maxDegree = nodeDegrees[nodeId];
                        rootNode = graphData.nodes.find(node => node.id.toString() === nodeId);
                    }
                });
                console.log('Most connected node:', rootNode ? rootNode.id : 'none', 'with degree:', maxDegree);
            }
            
            if (!rootNode) {
                rootNode = graphData.nodes[0]; // Fallback to first node
                console.log('Using fallback root node:', rootNode.id);
            }
            
            console.log('Selected root node:', rootNode);
            
            // Build tree structure using BFS
            const visited = new Set();
            const nodeMap = new Map();
            
            // Initialize nodes map
            graphData.nodes.forEach(node => {
                nodeMap.set(node.id.toString(), {
                    id: node.id,
                    label: node.label || node.id,
                    color: node.color || '#69b3a2',
                    children: [],
                    isRoot: node.id === rootNode.id
                });
            });
            
            console.log('Node map created with', nodeMap.size, 'nodes');
            
            // Build adjacency list and preserve link colors
            const adjacency = new Map();
            const linkColors = new Map(); // Store link colors
            graphData.links.forEach(link => {
                // Handle both object and string formats for source/target
                const sourceId = (typeof link.source === 'object') ? link.source.id.toString() : link.source.toString();
                const targetId = (typeof link.target === 'object') ? link.target.id.toString() : link.target.toString();
                
                if (!adjacency.has(sourceId)) adjacency.set(sourceId, []);
                if (!adjacency.has(targetId)) adjacency.set(targetId, []);
                
                adjacency.get(sourceId).push(targetId);
                adjacency.get(targetId).push(sourceId);
                
                // Store link color for both directions
                const linkKey1 = `${sourceId}-${targetId}`;
                const linkKey2 = `${targetId}-${sourceId}`;
                linkColors.set(linkKey1, link.color || '#999');
                linkColors.set(linkKey2, link.color || '#999');
            });
            
            console.log('Adjacency list created for', adjacency.size, 'nodes');
            
            // BFS to build tree
            const queue = [rootNode.id.toString()];
            visited.add(rootNode.id.toString());
            
            while (queue.length > 0) {
                const currentId = queue.shift();
                const currentNode = nodeMap.get(currentId);
                
                if (!currentNode) {
                    console.warn('Node not found in nodeMap:', currentId);
                    continue;
                }
                
                const neighbors = adjacency.get(currentId) || [];
                neighbors.forEach(neighborId => {
                    if (!visited.has(neighborId)) {
                        visited.add(neighborId);
                        queue.push(neighborId);
                        const neighborNode = nodeMap.get(neighborId);
                        if (neighborNode) {
                            currentNode.children.push(neighborNode);
                        }
                    }
                });
            }
            
            const result = nodeMap.get(rootNode.id.toString());
            console.log('Tree conversion result:', result);
            console.log('Tree has', visited.size, 'nodes out of', graphData.nodes.length, 'total nodes');
            
            return { tree: result, linkColors: linkColors };
        }

        async function renderNetworkGraph() {
            console.log('renderNetworkGraph called with D3.js');
            
            if (!apiData.graph || !apiData.graph.nodes || !apiData.graph.links) {
                console.warn('No graph data available for rendering');
                return;
            }

            const container = document.getElementById('network-graph');
            if (!container) {
                console.warn('Network graph container not found');
                return;
            }
            
            // Check if container has proper dimensions
            if (container.offsetWidth === 0 || container.offsetHeight === 0) {
                console.warn('Container has no dimensions, retrying in 100ms...');
                setTimeout(() => renderNetworkGraph(), 100);
                return;
            }
            
            // Check which graph view is selected
            const fullGraphRadio = document.getElementById('show-full-graph');
            const subgraphRadio = document.getElementById('show-subgraph');
            const treeRadio = document.getElementById('show-tree');
            
            let viewMode = 'subgraph'; // default
            if (fullGraphRadio && fullGraphRadio.checked) viewMode = 'full';
            else if (treeRadio && treeRadio.checked) viewMode = 'tree';
            
            console.log('Selected view mode:', viewMode);
            console.log('Selected account:', selectedAccount);
            
            // Handle tree view
            if (viewMode === 'tree') {
                await renderTreeGraph();
                return;
            }
            
            // Handle graph views (full and subgraph)
            let graphData;
            const canCreateSubgraph = selectedAccount || (apiData.customerInfo && apiData.customerInfo.frmtd_acct_no);
            
            if (viewMode === 'full') {
                graphData = apiData.graph;
                console.log('Using full graph data');
            } else if (viewMode === 'subgraph' && canCreateSubgraph) {
                console.log('Getting subgraph data...');
                graphData = await getSubgraphData();
                console.log('Subgraph data received:', {
                    hasSubgraphNodeIds: !!graphData.subgraphNodeIds,
                    subgraphNodeCount: graphData.subgraphNodeIds ? graphData.subgraphNodeIds.size : 0,
                    centerNodeId: graphData.centerNodeId
                });
            } else {
                // Fallback: show full graph
                graphData = apiData.graph;
                console.log('Using full graph data (fallback)');
            }
            
            // Determine if we're showing full graph or subgraph
            const showFullGraph = viewMode === 'full';
            
            console.log('Found container:', container);
            console.log('Container dimensions:', { offsetWidth: container.offsetWidth, offsetHeight: container.offsetHeight, clientWidth: container.clientWidth, clientHeight: container.clientHeight });
            console.log('Graph data for rendering:', graphData);
            console.log('Show full graph:', showFullGraph);

            try {
                // Clear the container and any placeholder content
                container.innerHTML = '';
                
                // Set up the SVG with responsive dimensions
                const containerRect = container.getBoundingClientRect();
                const width = container.clientWidth || containerRect.width || 600;
                const height = container.clientHeight || 400;
                
                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', '100%')
                    .attr('height', '100%')
                    .attr('viewBox', `0 0 ${width} ${height}`)
                    .attr('preserveAspectRatio', 'xMidYMid meet')
                    .style('border', '1px solid #e5e7eb')
                    .style('border-radius', '8px')
                    .style('background-color', '#f8fafc');
                
                // Store references globally for zoom functions
                window.currentSvg = svg.node();
                window.currentGraphData = graphData; // Store current graph data globally
                
                // Add zoom behavior
                const zoom = d3.zoom()
                    .scaleExtent([0.5, 3])
                    .on('zoom', (event) => {
                        g.attr('transform', event.transform);
                    });
                
                svg.call(zoom);
                window.currentZoom = zoom;
                
                // Create a group for the graph
                const g = svg.append('g');
                
                // Set up force simulation with circular layout
                const simulation = d3.forceSimulation(graphData.nodes)
                    .force('link', d3.forceLink(graphData.links).id(d => d.id).distance(100))
                    .force('charge', d3.forceManyBody().strength(-400))
                    .force('center', d3.forceCenter(width / 2, height / 2))
                    .force('collision', d3.forceCollide().radius(25))
                    .force('x', d3.forceX(width / 2).strength(0.1))
                    .force('y', d3.forceY(height / 2).strength(0.1));
                
                // Create the links with visibility control
                const links = g.append('g')
                    .selectAll('line')
                    .data(graphData.links)
                    .enter()
                    .append('line')
                    .attr('class', 'graph-link') // Added class for easier selection
                    .attr('stroke', d => d.color || '#999')
                    .attr('stroke-width', 1)
                    .attr('stroke-opacity', d => {
                        if (showFullGraph) return 0.3;
                        // For true subgraph mode, all links are visible (API filtered them already)
                        if (graphData.isSubgraph) return 0.3;
                        // Legacy subgraph mode with visibility control (fallback)
                        const sourceId = (typeof d.source === 'object') ? d.source.id : d.source;
                        const targetId = (typeof d.target === 'object') ? d.target.id : d.target;
                        const isSubgraphLink = graphData.subgraphNodeIds && 
                            graphData.subgraphNodeIds.has(sourceId) && 
                            graphData.subgraphNodeIds.has(targetId);
                        return isSubgraphLink ? 0.3 : 0; // Hide non-subgraph links
                    });
                
                // Create link labels (relationship text) - hidden by default
                const linkLabels = g.append('g')
                    .selectAll('text')
                    .data(graphData.links)
                    .enter()
                    .append('text')
                    .attr('class', 'link-label')
                    .attr('font-size', '10px')
                    .attr('font-weight', 'bold')
                    .attr('fill', d => d.color || '#999')
                    .attr('text-anchor', 'middle')
                    .attr('pointer-events', 'none')
                    .attr('opacity', 0) // Hidden by default
                    .text(d => d.relationship);
                
                // Create the nodes with initial circular positioning and visibility control
                const nodes = g.append('g')
                    .selectAll('circle')
                    .data(graphData.nodes)
                    .enter()
                    .append('circle')
                    .attr('r', 12)
                    .attr('fill', d => d.color || '#666')
                    .attr('stroke', '#333')
                    .attr('stroke-width', 1.5)
                    .attr('opacity', d => {
                        if (showFullGraph) return 0.8;
                        // For true subgraph mode, all nodes are visible (API filtered them already)
                        if (graphData.isSubgraph) return 0.8;
                        // Legacy subgraph mode with visibility control (fallback)
                        const isSubgraphNode = graphData.subgraphNodeIds && graphData.subgraphNodeIds.has(d.id);
                        if (isSubgraphNode) {
                            console.log(`Node ${d.id} is visible (subgraph member)`);
                        }
                        return isSubgraphNode ? 0.8 : 0; // Hide non-subgraph nodes
                    })
                    .attr('cursor', 'pointer')
                    .on('mouseover', function(event, d) {
                        console.log('Graph node hovered:', d.label || d.id);
                        
                        // Enlarge the hovered node
                        d3.select(this)
                            .transition()
                            .duration(200)
                            .attr('r', 18)
                            .attr('stroke-width', 3);
                        
                        // Highlight connected edges and relationships
                        highlightNodeConnections(d);
                        
                    })
                    .on('mouseout', function(event, d) {
                        // Reset node size and appearance
                        d3.select(this)
                            .transition()
                            .duration(200)
                            .attr('r', 12)
                            .attr('stroke-width', 1.5);
                        
                        // Reset all highlighting
                        resetHighlighting();
                        
                    })
                    .each(function(d, i) {
                        // Set initial positions in a circle
                        const angle = (i / graphData.nodes.length) * 2 * Math.PI;
                        const radius = Math.min(width, height) * 0.3;
                        d.x = width / 2 + radius * Math.cos(angle);
                        d.y = height / 2 + radius * Math.sin(angle);
                    });
                
                // Add labels to nodes with visibility control
                const labels = g.append('g')
                    .selectAll('text')
                    .data(graphData.nodes)
                    .enter()
                    .append('text')
                    .text(d => d.id)
                    .attr('font-size', '10px')
                    .attr('font-weight', 'bold')
                    .attr('text-anchor', 'middle')
                    .attr('dy', '0.35em')
                    .attr('fill', '#333')
                    .attr('pointer-events', 'none')
                    .attr('opacity', d => {
                        if (showFullGraph) return 1;
                        // For true subgraph mode, all labels are visible (API filtered them already)
                        if (graphData.isSubgraph) return 1;
                        // Legacy subgraph mode with visibility control (fallback)
                        const isSubgraphNode = graphData.subgraphNodeIds && graphData.subgraphNodeIds.has(d.id);
                        return isSubgraphNode ? 1 : 0; // Hide non-subgraph labels
                    });
                
                // Update positions on simulation tick
                simulation.on('tick', () => {
                    links
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y);
                    
                    // Position link labels in the middle of each edge
                    linkLabels
                        .attr('x', d => (d.source.x + d.target.x) / 2)
                        .attr('y', d => (d.source.y + d.target.y) / 2);
                    
                    nodes
                        .attr('cx', d => d.x)
                        .attr('cy', d => d.y);
                    
                    labels
                        .attr('x', d => d.x)
                        .attr('y', d => d.y);
                });
                
                // Add drag behavior
                nodes.call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
                
                function dragstarted(event, d) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                }
                
                function dragged(event, d) {
                    d.fx = event.x;
                    d.fy = event.y;
                }
                
                function dragended(event, d) {
                    if (!event.active) simulation.alphaTarget(0);
                    d.fx = null;
                    d.fy = null;
                }
                
                console.log('D3.js network graph rendered successfully');
                
                // Update graph statistics display
                updateGraphStatistics(graphData, showFullGraph);
                
                // Add resize handler for responsive behavior
                const resizeObserver = new ResizeObserver(() => {
                    const newWidth = container.clientWidth || 600;
                    const newHeight = container.clientHeight || 400;
                    
                    // Update SVG viewBox
                    svg.attr('viewBox', `0 0 ${newWidth} ${newHeight}`);
                    
                    // Update force simulation center
                    simulation.force('center', d3.forceCenter(newWidth / 2, newHeight / 2));
                    
                    // Restart simulation to reposition nodes
                    simulation.alpha(0.3).restart();
                });
                
                resizeObserver.observe(container);
                
            } catch (error) {
                console.error('Error rendering D3.js network graph:', error);
                container.innerHTML = `
                    <div class="text-center py-8 text-red-500">
                        <i data-lucide="alert-circle" class="w-8 h-8 mx-auto mb-2 text-red-300"></i>
                        <p>Error rendering network graph</p>
                        <p class="text-xs text-gray-500 mt-1">${error.message}</p>
                    </div>
                `;
            }
        }

        // Update graph statistics display
        function updateGraphStatistics(graphData, showFullGraph) {
            const statsElement = document.getElementById('graph-stats');
            if (statsElement) {
                const totalNodes = apiData.graph ? apiData.graph.nodes.length : 0;
                const totalLinks = apiData.graph ? apiData.graph.links.length : 0;
                
                const canCreateSubgraph = selectedAccount || (apiData.customerInfo && apiData.customerInfo.frmtd_acct_no);
                
                if (showFullGraph) {
                    const currentNodes = graphData.nodes.length;
                    const currentLinks = graphData.links.length;
                    statsElement.textContent = `The graph has ${currentNodes} nodes and ${currentLinks} linkages (full graph mode)`;
                } else if (canCreateSubgraph) {
                    // For subgraph mode, count nodes and links
                    let visibleNodes, visibleLinks;
                    
                    if (graphData.isSubgraph) {
                        // True subgraph from API - count actual nodes and links
                        visibleNodes = graphData.nodes.length;
                        visibleLinks = graphData.links.length;
                    } else {
                        // Legacy subgraph mode with visibility control (fallback)
                        visibleNodes = graphData.subgraphNodeIds ? graphData.subgraphNodeIds.size : 0;
                        visibleLinks = graphData.links ? graphData.links.filter(link => {
                            if (!graphData.subgraphNodeIds) return false;
                            // Handle both string IDs and object references
                            const sourceId = (typeof link.source === 'object') ? link.source.id : link.source;
                            const targetId = (typeof link.target === 'object') ? link.target.id : link.target;
                            return graphData.subgraphNodeIds.has(sourceId) && graphData.subgraphNodeIds.has(targetId);
                        }).length : 0;
                    }
                    
                    const degreeText = graphData.degree ? `${graphData.degree}-degree` : '1-degree';
                    if (!selectedAccount && apiData.customerInfo && apiData.customerInfo.frmtd_acct_no) {
                        statsElement.textContent = `Subgraph: ${visibleNodes} nodes and ${visibleLinks} linkages (target account + ${degreeText} neighbors)`;
                    } else {
                        statsElement.textContent = `Subgraph: ${visibleNodes} nodes and ${visibleLinks} linkages (selected account + ${degreeText} neighbors)`;
                    }
                } else {
                    // Fallback case
                    const currentNodes = graphData.nodes.length;
                    const currentLinks = graphData.links.length;
                    statsElement.textContent = `The graph has ${currentNodes} nodes and ${currentLinks} linkages (no account/target available)`;
                }
            }
            
            // Update tables to show only entries for current graph nodes
            updateTablesForCurrentGraph(graphData);
        }

        // Create public info content with both public-info and public-address
        function createPublicInfoContent() {
            console.log('Creating public info content with apiData:', apiData);
            
            // Check if data exists and has content
            const hasPublicInfo = apiData.publicInfo && Object.keys(apiData.publicInfo).length > 0;
            const hasPublicAddress = apiData.publicAddress && Object.keys(apiData.publicAddress).length > 0;
            
                         if (!hasPublicInfo && !hasPublicAddress) {
                 return `
                     <div class="text-center">
                         <div class="w-12 h-12 bg-primary-100 rounded-lg flex items-center justify-center mx-auto mb-2">
                             <i data-lucide="building" class="w-6 h-6 text-primary-600"></i>
                         </div>
                         <p class="text-xs text-gray-600">No company information available</p>
                         <p class="text-xs text-gray-500 mt-1">Check if the API endpoints are working correctly</p>
                     </div>
                 `;
             }

            let contentHtml = '';

                         // Add public info section
             if (apiData.publicInfo || apiData.publicAddress) {
                 contentHtml += `
                     <div class="mb-3">
                         ${formatPublicInfoData(apiData.publicInfo, apiData.publicAddress)}
                     </div>
                 `;
             }


            return contentHtml;
        }

        // Format public info data
        function formatPublicInfoData(data, addressData) {
            // Format company info data
            let companyInfoRows = '';
            if (typeof data === 'string') {
                companyInfoRows = `
                    <tr>
                        <td style="padding: 0px 4px; font-size: 12px; color: #374151; border: 1px solid #e5e7eb; background-color: white; text-align: left; vertical-align: top; word-break: break-word; white-space: pre-line;">
                            ${formatText(data).replace(/\n\n+/g, '\n').replace(/[ ]*-[ ]*/g, '').trim().replace(/^\s+/, '').replace(/^\s+/, '')}
                        </td>
                    </tr>
                `;
            } else if (typeof data === 'object' && data !== null) {
                const entries = Object.entries(data);
                if (entries.length === 0) {
                    companyInfoRows = '<tr><td style="padding: 0px 4px; font-size: 12px; color: #374151; border: 1px solid #e5e7eb; background-color: white; text-align: left; vertical-align: top;">No company information available</td></tr>';
                } else {
                    companyInfoRows = entries.map(([key, value]) => {
                        let formattedValue;
                        
                        if (typeof value === 'string') {
                            formattedValue = formatText(value).replace(/\n\n+/g, '\n').replace(/[ ]*-[ ]*/g, '').trim().replace(/^\s+/, '');
                        } else if (typeof value === 'object' && value !== null) {
                            formattedValue = formatDictValue(value, 0).replace(/\n\n+/g, '\n').replace(/[ ]*-[ ]*/g, '').trim().replace(/^\s+/, '');
                        } else {
                            formattedValue = String(value).replace(/\n\n+/g, '\n').replace(/[ ]*-[ ]*/g, '').trim().replace(/^\s+/, '');
                        }

                        return `
                            <tr>
                                <td style="padding: 0px 4px; font-size: 12px; color: #374151; border: 1px solid #e5e7eb; background-color: white; text-align: left; vertical-align: top; word-break: break-word; white-space: pre-line;">
                                    ${formattedValue}
                                </td>
                            </tr>
                        `;
                    }).join('');
                }
            } else {
                companyInfoRows = '<tr><td style="padding: 0px 4px; font-size: 12px; color: #374151; border: 1px solid #e5e7eb; background-color: white; text-align: left; vertical-align: top;">No company information available</td></tr>';
            }

            // Format address data
            let addressRows = '';
            if (typeof addressData === 'string') {
                addressRows = `
                    <tr>
                        <td style="padding: 0px 4px; font-size: 12px; color: #374151; border: 1px solid #e5e7eb; background-color: white; text-align: left; vertical-align: top; word-break: break-word; white-space: pre-line;">
                            ${formatText(addressData).replace(/\n\n+/g, '\n').replace(/[ ]*-[ ]*/g, '').trim().replace(/^\s+/, '')}
                        </td>
                    </tr>
                `;
            } else if (typeof addressData === 'object' && addressData !== null) {
                const entries = Object.entries(addressData);
                if (entries.length === 0) {
                    addressRows = '<tr><td style="padding: 0px 4px; font-size: 12px; color: #374151; border: 1px solid #e5e7eb; background-color: white; text-align: left; vertical-align: top;">No address information available</td></tr>';
                } else {
                    addressRows = entries.map(([key, value]) => {
                        let formattedValue;
                        
                        if (typeof value === 'string') {
                            formattedValue = formatText(value).replace(/\n\n+/g, '\n').replace(/[ ]*-[ ]*/g, '').trim().replace(/^\s+/, '');
                        } else if (typeof value === 'object' && value !== null) {
                            formattedValue = formatDictValue(value, 0).replace(/\n\n+/g, '\n').replace(/[ ]*-[ ]*/g, '').trim().replace(/^\s+/, '');
                        } else {
                            formattedValue = String(value).replace(/\n\n+/g, '\n').replace(/[ ]*-[ ]*/g, '').trim().replace(/^\s+/, '');
                        }

                        return `
                            <tr>
                                <td style="padding: 0px 4px; font-size: 12px; color: #374151; border: 1px solid #e5e7eb; background-color: white; text-align: left; vertical-align: top; word-break: break-word; white-space: pre-line;">
                                    ${formattedValue}
                                </td>
                            </tr>
                        `;
                    }).join('');
                }
            } else {
                addressRows = '<tr><td style="padding: 0px 4px; font-size: 12px; color: #374151; border: 1px solid #e5e7eb; background-color: white; text-align: left; vertical-align: top;">No address information available</td></tr>';
            }

            return `
                <table style="width: 100%; border-collapse: collapse; font-size: 13px;">
                    <thead>
                        <tr>
                            <th data-sortable="true" style="width: 55%; padding: 0px 6px; font-size: 13px; font-weight: bold; color: #374151; border: 1px solid #e5e7eb; background-color: #f3f4f6; text-align: left; cursor: pointer; user-select: none;" onmouseover="this.style.backgroundColor='#e5e7eb'" onmouseout="this.style.backgroundColor='#f3f4f6'">
                                Company Information<span class="sort-icon"></span>
                            </th>
                            <th data-sortable="true" style="width: 45%; padding: 0px 6px; font-size: 13px; font-weight: bold; color: #374151; border: 1px solid #e5e7eb; background-color: #f3f4f6; text-align: left; cursor: pointer; user-select: none;" onmouseover="this.style.backgroundColor='#e5e7eb'" onmouseout="this.style.backgroundColor='#f3f4f6'">
                                Address Information<span class="sort-icon"></span>
                            </th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="width: 55%; padding: 0px 4px; font-size: 12px; color: #374151; border: 1px solid #e5e7eb; background-color: white; text-align: left; vertical-align: top; word-break: break-word; white-space: pre-line;">
                                ${companyInfoRows.replace(/<tr>|<\/tr>/g, '').replace(/<td[^>]*>|<\/td>/g, '')}
                            </td>
                            <td style="width: 45%; padding: 0px 4px; font-size: 12px; color: #374151; border: 1px solid #e5e7eb; background-color: white; text-align: left; vertical-align: top; word-break: break-word; white-space: pre-line;">
                                ${addressRows.replace(/<tr>|<\/tr>/g, '').replace(/<td[^>]*>|<\/td>/g, '')}
                            </td>
                        </tr>
                    </tbody>
                </table>
            `;
        }

        // Format public address data
        function formatPublicAddressData(data) {
            if (typeof data === 'string') {
                return `<div class="text-xs text-gray-700 leading-relaxed">${formatText(data)}</div>`;
            } else if (typeof data === 'object' && data !== null) {
                const entries = Object.entries(data);
                if (entries.length === 0) {
                    return '<div class="text-xs text-gray-700">No address information available</div>';
                }

                return entries.map(([key, value]) => {
                    const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    let formattedValue;
                    
                    if (typeof value === 'string') {
                        formattedValue = formatText(value);
                    } else if (typeof value === 'object' && value !== null) {
                        formattedValue = formatDictValue(value, 0);
                    } else {
                        formattedValue = String(value);
                    }

                    return `
                        <div class="mb-2 border-b border-gray-200 pb-2 last:border-b-0">
                            <h5 class="text-sm font-semibold text-gray-900 mb-1">${formattedKey}</h5>
                            <div class="text-xs text-gray-700 leading-relaxed">${formattedValue}</div>
                        </div>
                    `;
                }).join('');
            } else {
                return '<div class="text-xs text-gray-700">No address information available</div>';
            }
        }

        // Recursive function to format dictionary values
        function formatDictValue(value, depth = 0) {
            if (typeof value === 'string') {
                return formatText(value);
            } else if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                // Handle nested dictionaries
                const indent = '  '.repeat(depth);
                const entries = Object.entries(value);
                
                if (entries.length === 0) {
                    return '{}';
                }
                
                const formattedEntries = entries.map(([nestedKey, nestedValue]) => {
                    const formattedNestedKey = nestedKey.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    const formattedNestedValue = formatDictValue(nestedValue, depth + 1);
                    
                    if (typeof nestedValue === 'object' && nestedValue !== null && !Array.isArray(nestedValue)) {
                        // For nested objects, create a structured display
                        return `
                            <div class="ml-${Math.min(depth * 4, 16)} mb-3">
                                <div class="font-medium text-gray-800 mb-2">${formattedNestedKey}</div>
                                <div class="ml-4">${formattedNestedValue}</div>
                            </div>
                        `;
                    } else {
                        // For simple values, display inline
                        return `
                            <div class="ml-${Math.min(depth * 4, 16)} mb-2">
                                <span class="font-medium text-gray-800">${formattedNestedKey}:</span>
                                <span class="ml-2">${formattedNestedValue}</span>
                            </div>
                        `;
                    }
                }).join('');
                
                return `<div class="border-l-2 border-gray-200 pl-4">${formattedEntries}</div>`;
            } else if (Array.isArray(value)) {
                // Handle arrays
                if (value.length === 0) {
                    return '[]';
                }
                
                const formattedItems = value.map((item, index) => {
                    const formattedItem = formatDictValue(item, depth + 1);
                    return `
                        <div class="ml-${Math.min(depth * 4, 16)} mb-2">
                            <span class="text-gray-600">[${index}]:</span>
                            <span class="ml-2">${formattedItem}</span>
                        </div>
                    `;
                }).join('');
                
                return `<div class="border-l-2 border-gray-200 pl-4">${formattedItems}</div>`;
            } else {
                // Handle other types (numbers, booleans, null, undefined)
                return String(value);
            }
        }

        // Consolidated text formatting function for reuse across different sections
        function formatText(text) {
            if (!text || typeof text !== 'string') {
                return text;
            }
            
            let formattedText = text;
            
            // Rule 0: Protect compound words by temporarily replacing them
            const compoundWords = ['non-financial-account', 'self-employed', 'risk-based', 'pre-existing'];
            const protectedWords = {};
            
            compoundWords.forEach((word, index) => {
                if (formattedText.includes(word)) {
                    console.log(`Found compound word: ${word} in text`);
                    const placeholder = `__PROTECTED_${index}__`;
                    protectedWords[placeholder] = word;
                    formattedText = formattedText.replace(new RegExp(word, 'g'), placeholder);
                    console.log(`Replaced ${word} with ${placeholder}`);
                }
            });
            
            // Rule 1: Convert /n to line breaks
            formattedText = formattedText.replace(/\/n/g, '<br/>');
            
            // Rule 2: Handle . **text** - convert to period + two line breaks + bold
            // Only apply if there are spaces after the period and before the **
            formattedText = formattedText.replace(/\.\s+\*\*([^*]+)\*\*/g, '.<br/><br/><strong>$1</strong>');
            
            // Rule 3: Convert remaining **text** to bold (for regular cases)
            formattedText = formattedText.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
            
            // Rule 4: Convert "text - text:" pattern to "text<br/>text" (with line break)
            // This handles cases like "hello - finance:" becoming "hello<br/>finance"
            formattedText = formattedText.replace(/(\w+)\s*-\s*(\w+):/g, '$1<br/>$2');
            
            // Rule 5: Restore protected compound words
            Object.keys(protectedWords).forEach(placeholder => {
                console.log(`Restoring ${placeholder} back to ${protectedWords[placeholder]}`);
                formattedText = formattedText.replace(new RegExp(placeholder, 'g'), protectedWords[placeholder]);
            });
            
            // Final debug
            if (text.includes('non-financial-account')) {
                console.log('FINAL RESULT:', formattedText.substring(formattedText.indexOf('non') - 20, formattedText.indexOf('non') + 50));
            }
            
            return formattedText;
        }


                 // Create business pattern content
         function createBusinessPatternContent() {
             if (!apiData.businessPattern) {
                 return `
                     <div class="text-center">
                         <div class="w-12 h-12 bg-primary-100 rounded-lg flex items-center justify-center mx-auto mb-2">
                         <i data-lucide="bar-chart-3" class="w-6 h-6 text-primary-600"></i>
                     </div>
                     <p class="text-xs text-gray-600">Loading business pattern analysis data...</p>
                 `;
             }

            // Check if dict_analysis exists, otherwise use raw_analysis
            let contentHtml = '';
            if (apiData.businessPattern && apiData.businessPattern.dict_analysis) {
                // Check if dict_analysis is a string or an object
                if (typeof apiData.businessPattern.dict_analysis === 'string') {
                    // If dict_analysis is a string, display it as text
                    const formattedText = formatText(apiData.businessPattern.dict_analysis);
                    console.log('Formatted text:', formattedText);
                    contentHtml = `<div class="text-sm text-gray-700 leading-relaxed" style="word-break: keep-all; hyphens: none;">${formattedText}</div>`;
                } else if (typeof apiData.businessPattern.dict_analysis === 'object' && apiData.businessPattern.dict_analysis !== null) {
                    // Handle dict_analysis as object - display key-value pairs
                    contentHtml = Object.entries(apiData.businessPattern.dict_analysis).map(([key, value]) => {
                        // Format the key to be more readable and apply text formatting
                        const formattedKey = formatText(key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()));
                        
                        // Format the value with text formatting
                        let formattedValue;
                        if (typeof value === 'string') {
                            formattedValue = formatText(value);
                        } else {
                            formattedValue = JSON.stringify(value, null, 2);
                        }
                        
                        return `
                            <div class="mb-3 border-b border-gray-200 pb-2 last:border-b-0">
                                <h4 class="text-sm font-semibold text-gray-900 mb-1">${formattedKey}</h4>
                                <div class="text-xs text-gray-700 leading-relaxed" style="word-break: keep-all; hyphens: none;">${formattedValue}</div>
                            </div>
                        `;
                    }).join('');
                } else {
                    // Fallback for other dict_analysis types
                    contentHtml = `<div class="text-sm text-gray-700 leading-relaxed">Invalid dict_analysis format</div>`;
                }
            } else if (apiData.businessPattern && apiData.businessPattern.raw_analysis) {
                // Handle raw_analysis with consolidated text formatting
                const formattedText = formatText(apiData.businessPattern.raw_analysis);
                contentHtml = `<div class="text-sm text-gray-700 leading-relaxed" style="word-break: keep-all; hyphens: none;">${formattedText}</div>`;
            } else {
                // Fallback for other data types
                contentHtml = `<div class="text-sm text-gray-700 leading-relaxed">No business pattern data available</div>`;
            }

                         return `
                 <!-- Overall Summary Section with Customer Info Table -->
                 <div class="bg-gradient-to-br from-gray-50 to-gray-100 rounded-lg p-2">
                     <div class="prose prose-gray max-w-none">
                         <div class="bg-white rounded-lg p-2 shadow-sm">
                             <!-- Customer Info Table First -->
                             ${createCustomerInfoContent()}
                             
                             <!-- Overall Summary Content -->
                             <div class="mt-4 pt-4 border-t border-gray-200">
                             ${contentHtml}
                             </div>
                         </div>
                     </div>
                 </div>
             `;
        }

        // Fetch transaction usage detail data
        async function fetchTransactionUsageDetail(transactionType, category = null, direction = null, userCategory = null) {
            try {
                const response = await fetch(`/api/transactions_usage_detail_dict?acctno=${selectedAccount}&transaction_type=${encodeURIComponent(transactionType)}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                let data = await response.json();
                
                // Apply frontend filtering if filters are provided
                if (data && (category || direction || userCategory)) {
                    console.log('=== APPLYING FRONTEND FILTERS ===');
                    console.log('Original data count:', Array.isArray(data) ? data.length : Object.keys(data).length);
                    console.log('Filters applied:', { category, direction, userCategory });
                    
                    data = filterTransactionDetailData(data, category, direction, userCategory);
                    
                    console.log('Filtered data count:', Array.isArray(data) ? data.length : Object.keys(data).length);
                    console.log('=== END FILTERING ===');
                }
                
                return data;
            } catch (error) {
                console.error('Error fetching transaction usage detail:', error);
                return null;
            }
        }

        // Filter transaction detail data on the frontend
        function filterTransactionDetailData(data, category, direction, userCategory) {
            console.log('=== FILTER FUNCTION START ===');
            console.log('Input data:', data);
            console.log('Data type:', Array.isArray(data) ? 'array' : typeof data);
            console.log('Filter values:', { category, direction, userCategory });
            
            if (!data) {
                console.log('No data to filter, returning null');
                return data;
            }
            
            // Handle array data
            if (Array.isArray(data)) {
                console.log('Processing array data with', data.length, 'items');
                
                if (data.length > 0) {
                    console.log('Sample item structure:', data[0]);
                    console.log('Sample item keys:', Object.keys(data[0]));
                    console.log('Sample item values:');
                    Object.keys(data[0]).forEach(key => {
                        console.log(`  ${key}: "${data[0][key]}" (type: ${typeof data[0][key]})`);
                    });
                }
                
                const filtered = data.filter((item, index) => {
                    console.log(`\n--- Checking Item ${index} ---`);
                    console.log('Item:', item);
                    
                    if (typeof item !== 'object' || item === null) {
                        console.log(`Item ${index}: Not an object, skipping`);
                        return false;
                    }
                    
                    let passesAllFilters = true;
                    
                    // Check category filter
                    if (category && category.replace(/\n\n+/g, '\n').replace(/[ ]*-[ ]*/g, '').trim().replace(/^\s+/, '') !== '') {
                        const itemCategory = String(item.category || '').replace(/\n\n+/g, '\n').replace(/[ ]*-[ ]*/g, '').trim().replace(/^\s+/, '');
                        const filterCategory = String(category).replace(/\n\n+/g, '\n').replace(/[ ]*-[ ]*/g, '').trim().replace(/^\s+/, '');
                        const categoryMatch = itemCategory.toLowerCase() === filterCategory.toLowerCase();
                        
                        console.log(`Category comparison:`);
                        console.log(`  Item category: "${itemCategory}"`);
                        console.log(`  Filter category: "${filterCategory}"`);
                        console.log(`  Match: ${categoryMatch}`);
                        
                        if (!categoryMatch) {
                            console.log(`   Category filter FAILED`);
                            passesAllFilters = false;
                        } else {
                            console.log(`   Category filter PASSED`);
                        }
                    } else {
                        console.log('No category filter applied');
                    }
                    
                    // Check direction filter
                    if (direction && direction.replace(/\n\n+/g, '\n').replace(/[ ]*-[ ]*/g, '').trim().replace(/^\s+/, '') !== '' && passesAllFilters) {
                        const itemDirection = String(item.direction || '').replace(/\n\n+/g, '\n').replace(/[ ]*-[ ]*/g, '').trim().replace(/^\s+/, '');
                        const filterDirection = String(direction).replace(/\n\n+/g, '\n').replace(/[ ]*-[ ]*/g, '').trim().replace(/^\s+/, '');
                        const directionMatch = itemDirection.toLowerCase() === filterDirection.toLowerCase();
                        
                        console.log(`Direction comparison:`);
                        console.log(`  Item direction: "${itemDirection}"`);
                        console.log(`  Filter direction: "${filterDirection}"`);
                        console.log(`  Match: ${directionMatch}`);
                        
                        if (!directionMatch) {
                            console.log(`   Direction filter FAILED`);
                            passesAllFilters = false;
                        } else {
                            console.log(`   Direction filter PASSED`);
                        }
                    } else {
                        console.log('No direction filter applied or previous filter failed');
                    }
                    
                    // Check user category filter (usage_category)
                    if (userCategory && userCategory.replace(/\n\n+/g, '\n').replace(/[ ]*-[ ]*/g, '').trim().replace(/^\s+/, '') !== '' && passesAllFilters) {
                        const itemUsageCategory = String(item.usage_category || '').replace(/\n\n+/g, '\n').replace(/[ ]*-[ ]*/g, '').trim().replace(/^\s+/, '');
                        const filterUsageCategory = String(userCategory).replace(/\n\n+/g, '\n').replace(/[ ]*-[ ]*/g, '').trim().replace(/^\s+/, '');
                        const usageCategoryMatch = itemUsageCategory.toLowerCase() === filterUsageCategory.toLowerCase();
                        
                        console.log(`Usage category comparison:`);
                        console.log(`  Item usage_category: "${itemUsageCategory}"`);
                        console.log(`  Filter usage_category: "${filterUsageCategory}"`);
                        console.log(`  Match: ${usageCategoryMatch}`);
                        
                        if (!usageCategoryMatch) {
                            console.log(`   Usage category filter FAILED`);
                            passesAllFilters = false;
                        } else {
                            console.log(`   Usage category filter PASSED`);
                        }
                    } else {
                        console.log('No usage category filter applied or previous filter failed');
                    }
                    
                    console.log(`Item ${index} final result: ${passesAllFilters ? 'PASSED ALL FILTERS' : 'FAILED FILTERS'}`);
                    return passesAllFilters;
                });
                
                console.log(`\n=== FILTERING COMPLETE ===`);
                console.log(`Original items: ${data.length}`);
                console.log(`Filtered items: ${filtered.length}`);
                console.log(`Items removed: ${data.length - filtered.length}`);
                
                if (filtered.length > 0) {
                    console.log('Sample filtered item:', filtered[0]);
                } else {
                    console.log('No items passed the filters');
                }
                
                return filtered;
            }
            
            // Handle object data
            if (typeof data === 'object' && data !== null) {
                console.log('Processing object data with', Object.keys(data).length, 'keys');
                const filteredData = {};
                
                for (const [key, value] of Object.entries(data)) {
                    console.log(`\n--- Checking Key: "${key}" ---`);
                    console.log('Value:', value);
                    
                    let passesAllFilters = true;
                    
                    // For object data, we check if the key matches our filters
                    if (category && category.replace(/\n\n+/g, '\n').replace(/[ ]*-[ ]*/g, '').trim().replace(/^\s+/, '') !== '') {
                        const keyMatch = key.toLowerCase() === category.toLowerCase();
                        console.log(`Key category comparison: "${key}" === "${category}" ? ${keyMatch}`);
                        if (!keyMatch) {
                            console.log(`   Key category filter FAILED`);
                            passesAllFilters = false;
                        } else {
                            console.log(`   Key category filter PASSED`);
                        }
                    }
                    
                    // If the value is an object, check its properties
                    if (typeof value === 'object' && value !== null && passesAllFilters) {
                        if (direction && direction.replace(/\n\n+/g, '\n').replace(/[ ]*-[ ]*/g, '').trim().replace(/^\s+/, '') !== '') {
                            const itemDirection = String(value.direction || '').replace(/\n\n+/g, '\n').replace(/[ ]*-[ ]*/g, '').trim().replace(/^\s+/, '');
                            const filterDirection = String(direction).replace(/\n\n+/g, '\n').replace(/[ ]*-[ ]*/g, '').trim().replace(/^\s+/, '');
                            const directionMatch = itemDirection.toLowerCase() === filterDirection.toLowerCase();
                            console.log(`Value direction comparison: "${itemDirection}" === "${filterDirection}" ? ${directionMatch}`);
                            if (!directionMatch) {
                                console.log(`   Value direction filter FAILED`);
                                passesAllFilters = false;
                            } else {
                                console.log(`   Value direction filter PASSED`);
                            }
                        }
                        
                        if (userCategory && userCategory.replace(/\n\n+/g, '\n').replace(/[ ]*-[ ]*/g, '').trim().replace(/^\s+/, '') !== '' && passesAllFilters) {
                            const itemUsageCategory = String(value.usage_category || '').replace(/\n\n+/g, '\n').replace(/[ ]*-[ ]*/g, '').trim().replace(/^\s+/, '');
                            const filterUsageCategory = String(userCategory).replace(/\n\n+/g, '\n').replace(/[ ]*-[ ]*/g, '').trim().replace(/^\s+/, '');
                            const usageCategoryMatch = itemUsageCategory.toLowerCase() === filterUsageCategory.toLowerCase();
                            console.log(`Value usage category comparison: "${itemUsageCategory}" === "${filterUsageCategory}" ? ${usageCategoryMatch}`);
                            if (!usageCategoryMatch) {
                                console.log(`   Value usage category filter FAILED`);
                                passesAllFilters = false;
                            } else {
                                console.log(`   Value usage category filter PASSED`);
                            }
                        }
                    }
                    
                    if (passesAllFilters) {
                        console.log(`Key "${key}" PASSED ALL FILTERS`);
                        filteredData[key] = value;
                    } else {
                        console.log(`Key "${key}" FAILED FILTERS`);
                    }
                }
                
                console.log(`\n=== OBJECT FILTERING COMPLETE ===`);
                console.log(`Original keys: ${Object.keys(data).length}`);
                console.log(`Filtered keys: ${Object.keys(filteredData).length}`);
                console.log(`Keys removed: ${Object.keys(data).length - Object.keys(filteredData).length}`);
                
                return filteredData;
            }
            
            console.log('Data is neither array nor object, returning as-is');
            return data;
        }

        // Create transaction usage detail table HTML
        function createTransactionUsageDetailTable(data) {
            if (!data || (Array.isArray(data) && data.length === 0)) {
                return `
                    <div class="text-center py-8 text-gray-500">
                        <i data-lucide="file-x" class="w-8 h-8 mx-auto mb-2 text-gray-300"></i>
                        <p>No transaction usage detail data available</p>
                    </div>
                `;
            }

            let tableRows = '';
            
            if (Array.isArray(data)) {
                // Handle array data
                data.forEach((item, index) => {
                    if (typeof item === 'object' && item !== null) {
                        const keys = Object.keys(item);
                        if (keys.length > 0) {
                            tableRows += `
                                <tr>
                                    <td style="padding: 0px 4px; font-size: 12px; color: #374151; border: 1px solid #e5e7eb; background-color: white; text-align: left; vertical-align: top;">
                                        ${index + 1}
                                    </td>
                                    <td style="padding: 0px 4px; font-size: 12px; color: #374151; border: 1px solid #e5e7eb; background-color: white; text-align: left; vertical-align: top;">
                                        ${keys.join(', ')}
                                    </td>
                                    <td style="padding: 0px 4px; font-size: 12px; color: #374151; border: 1px solid #e5e7eb; background-color: white; text-align: left; vertical-align: top; word-break: break-word; white-space: pre-line;">
                                        ${keys.map(key => `${key}: ${JSON.stringify(item[key])}`).join('\n')}
                                    </td>
                                </tr>
                            `;
                        }
                    } else {
                        tableRows += `
                            <tr>
                                <td style="padding: 0px 4px; font-size: 12px; color: #374151; border: 1px solid #e5e7eb; background-color: white; text-align: left; vertical-align: top;">
                                    ${index + 1}
                                </td>
                                <td style="padding: 0px 4px; font-size: 12px; color: #374151; border: 1px solid #e5e7eb; background-color: white; text-align: left; vertical-align: top;">
                                    -
                                </td>
                                <td style="padding: 0px 4px; font-size: 12px; color: #374151; border: 1px solid #e5e7eb; background-color: white; text-align: left; vertical-align: top; word-break: break-word; white-space: pre-line;">
                                    ${JSON.stringify(item)}
                                </td>
                            </tr>
                        `;
                    }
                });
            } else if (typeof data === 'object' && data !== null) {
                // Handle object data
                const keys = Object.keys(data);
                keys.forEach((key, index) => {
                    const value = data[key];
                    tableRows += `
                        <tr>
                            <td style="padding: 0px 4px; font-size: 12px; color: #374151; border: 1px solid #e5e7eb; background-color: white; text-align: left; vertical-align: top;">
                                ${index + 1}
                            </td>
                            <td style="padding: 0px 4px; font-size: 12px; color: #374151; border: 1px solid #e5e7eb; background-color: white; text-align: left; vertical-align: top;">
                                ${key}
                            </td>
                            <td style="padding: 0px 4px; font-size: 12px; color: #374151; border: 1px solid #e5e7eb; background-color: white; text-align: left; vertical-align: top; word-break: break-word; white-space: pre-line;">
                                ${typeof value === 'object' ? JSON.stringify(value, null, 2) : String(value)}
                            </td>
                        </tr>
                    `;
                });
            } else {
                // Handle primitive data
                tableRows += `
                    <tr>
                        <td style="padding: 0px 4px; font-size: 12px; color: #374151; border: 1px solid #e5e7eb; background-color: white; text-align: left; vertical-align: top;">
                            1
                        </td>
                        <td style="padding: 0px 4px; font-size: 12px; color: #374151; border: 1px solid #e5e7eb; background-color: white; text-align: left; vertical-align: top;">
                            -
                        </td>
                        <td style="padding: 0px 4px; font-size: 12px; color: #374151; border: 1px solid #e5e7eb; background-color: white; text-align: left; vertical-align: top; word-break: break-word; white-space: pre-line;">
                            ${String(data)}
                        </td>
                    </tr>
                `;
            }

            return `
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse; font-size: 13px;">
                        <thead>
                            <tr>
                                <th data-sortable="true" style="padding: 10px 12px; font-size: 13px; font-weight: bold; color: #374151; border: 1px solid #e5e7eb; background-color: #f3f4f6; text-align: left; cursor: pointer; user-select: none; width: 80px;" onmouseover="this.style.backgroundColor='#e5e7eb'" onmouseout="this.style.backgroundColor='#f3f4f6'">
                                    #<span class="sort-icon"></span>
                                </th>
                                <th data-sortable="true" style="padding: 10px 12px; font-size: 13px; font-weight: bold; color: #374151; border: 1px solid #e5e7eb; background-color: #f3f4f6; text-align: left; cursor: pointer; user-select: none;" onmouseover="this.style.backgroundColor='#e5e7eb'" onmouseout="this.style.backgroundColor='#f3f4f6'">
                                    Key<span class="sort-icon"></span>
                                </th>
                                <th data-sortable="true" style="padding: 10px 12px; font-size: 13px; font-weight: bold; color: #374151; border: 1px solid #e5e7eb; background-color: #f3f4f6; text-align: left; cursor: pointer; user-select: none;" onmouseover="this.style.backgroundColor='#e5e7eb'" onmouseout="this.style.backgroundColor='#f3f4f6'">
                                    Value<span class="sort-icon"></span>
                                </th>
                            </tr>
                        </thead>
                        <tbody>
                            ${tableRows}
                        </tbody>
                    </table>
                </div>
            `;
        }

        // Show transaction detail modal
        async function showTransactionDetailModal(transactionType, category = null, direction = null, userCategory = null) {
            try {
                // Show the modal with loading state
                const modal = document.getElementById('transaction-detail-modal');
                const content = document.getElementById('transaction-detail-content');
                
                modal.classList.remove('hidden');
                
                // Build filter description
                let filterDesc = transactionType;
                if (category || direction || userCategory) {
                    const filters = [];
                    if (category) filters.push(`Category: ${category}`);
                    if (direction) filters.push(`Direction: ${direction}`);
                    if (userCategory) filters.push(`Usage Category: ${userCategory}`);
                    filterDesc += ` (${filters.join(', ')})`;
                }
                
                content.innerHTML = `
                    <div class="text-center py-8">
                        <i data-lucide="loader" class="w-8 h-8 mx-auto mb-2 animate-spin text-gray-400"></i>
                        <p class="text-gray-500">Loading transaction details for: ${filterDesc}</p>
                    </div>
                `;
                
                // Re-initialize Lucide icons for the loading spinner
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                }
                
                // Fetch the data with filters
                const data = await fetchTransactionUsageDetail(transactionType, category, direction, userCategory);
                
                if (data) {
                    // Generate the table HTML
                    const tableHtml = createTransactionUsageDetailTable(data);
                    content.innerHTML = `
                        <div class="mb-4">
                            <h4 class="text-sm font-semibold text-gray-900 mb-3 flex items-center">
                                <i data-lucide="list" class="w-4 h-4 mr-2"></i>
                                Transaction Details: ${filterDesc}
                            </h4>
                            ${tableHtml}
                        </div>
                    `;
                } else {
                    content.innerHTML = `
                        <div class="text-center py-8 text-gray-500">
                            <i data-lucide="alert-circle" class="w-8 h-8 mx-auto mb-2 text-gray-300"></i>
                            <p>Failed to load transaction details for: ${transactionType}</p>
                        </div>
                    `;
                }
                
                // Re-initialize Lucide icons for the content
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                }
                
            } catch (error) {
                console.error('Error showing transaction detail modal:', error);
                const content = document.getElementById('transaction-detail-content');
                content.innerHTML = `
                    <div class="text-center py-8 text-red-500">
                        <i data-lucide="x-circle" class="w-8 h-8 mx-auto mb-2"></i>
                        <p>Error loading transaction details: ${error.message}</p>
                    </div>
                `;
                
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                }
            }
        }

        // Create customer info content
        function createCustomerInfoContent() {
            if (!apiData.customerInfo) {
                return `
                    <div class="text-center">
                        <div class="w-12 h-12 bg-blue-100 rounded-lg flex items-center justify-center mx-auto mb-2">
                            <i data-lucide="users" class="w-6 h-6 text-blue-600"></i>
                        </div>
                        <p class="text-xs text-gray-600">Loading customer information data...</p>
                    </div>
                `;
            }

            // Check if customerInfo has content
            if (Object.keys(apiData.customerInfo).length === 0) {
                return `
                    <div class="text-center py-4 text-gray-500">
                        <i data-lucide="users" class="w-8 h-8 mx-auto mb-2 text-gray-300"></i>
                        <p>No customer information available</p>
                    </div>
                `;
            }

            // Handle different data types
            if (typeof apiData.customerInfo === 'string') {
                return `<div class="text-xs text-gray-700 leading-relaxed">${formatText(apiData.customerInfo)}</div>`;
            } else if (typeof apiData.customerInfo === 'object' && apiData.customerInfo !== null) {
                if (Array.isArray(apiData.customerInfo)) {
                    // Handle array data
                    if (apiData.customerInfo.length === 0) {
                        return '<div class="text-xs text-gray-700">No customer data available</div>';
                    }
                    
                    return createCustomerInfoTable(apiData.customerInfo);
                } else {
                    // Handle object data
                    return createCustomerInfoTable([apiData.customerInfo]);
                }
            } else {
                return `<div class="text-xs text-gray-700">${String(apiData.customerInfo)}</div>`;
            }
        }

        // Create customer info table
        function createCustomerInfoTable(data) {
            if (!data || data.length === 0) {
                return '<div class="text-xs text-gray-700">No customer data available</div>';
            }

            const firstItem = data[0];
            if (!firstItem || typeof firstItem !== 'object') {
                return '<div class="text-xs text-gray-700">Invalid customer data format</div>';
            }

            // Get all unique keys from all items
            const allKeys = new Set();
            data.forEach(item => {
                if (item && typeof item === 'object') {
                    Object.keys(item).forEach(key => allKeys.add(key));
                }
            });
            const keys = Array.from(allKeys);

            if (keys.length === 0) {
                return '<div class="text-xs text-gray-700">No customer data available</div>';
            }

            // Create table headers with sorting capability
            const tableHeaders = keys.map(key => {
                const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                return `<th data-sortable="true" style="padding: 10px 14px; font-size: 13px; font-weight: bold; color: #374151; border: 1px solid #e5e7eb; background-color: #f3f4f6; text-align: left; cursor: pointer; user-select: none;" onmouseover="this.style.backgroundColor='#e5e7eb'" onmouseout="this.style.backgroundColor='#f3f4f6'">${formattedKey}<span class="sort-icon"></span></th>`;
            }).join('');

            // Create table rows
            const tableRows = data.map((item, rowIndex) => {
                const rowCells = keys.map(key => {
                    const value = item[key];
                    let formattedValue;
                    
                    if (typeof value === 'string') {
                        formattedValue = formatText(value);
                    } else if (typeof value === 'number') {
                        formattedValue = value.toLocaleString('en-US');
                    } else if (typeof value === 'object' && value !== null) {
                        formattedValue = JSON.stringify(value);
                    } else {
                        formattedValue = String(value);
                    }

                    // Alternate row colors for better readability
                    const bgColor = rowIndex % 2 === 0 ? 'white' : '#f9fafb';
                    
                    return `<td style="padding: 10px 14px; font-size: 13px; color: #374151; border: 1px solid #e5e7eb; background-color: ${bgColor}; text-align: left; vertical-align: top;">${formattedValue}</td>`;
                }).join('');

                return `<tr>${rowCells}</tr>`;
            }).join('');

            return `
                <div style="overflow-x: auto;">
                    <table id="customer-info-table" style="width: 100%; border-collapse: collapse; font-size: 11px;">
                        <thead>
                            <tr>${tableHeaders}</tr>
                        </thead>
                        <tbody>
                            ${tableRows}
                        </tbody>
                    </table>
                </div>
            `;
        }

        // Format customer info object data (kept for compatibility)
        function formatCustomerInfoObject(data, prefix = '') {
            const entries = Object.entries(data);
            if (entries.length === 0) {
                return '<div class="text-xs text-gray-700">No customer information available</div>';
            }

            return entries.map(([key, value]) => {
                const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                let formattedValue;
                
                if (typeof value === 'string') {
                    formattedValue = formatText(value);
                } else if (typeof value === 'object' && value !== null) {
                    formattedValue = formatDictValue(value, 0);
                } else {
                    formattedValue = String(value);
                }

                const keyId = prefix ? `${prefix}_${key}` : key;
                
                return `
                    <div class="mb-2 border-b border-gray-200 pb-2 last:border-b-0">
                        <h5 class="text-sm font-semibold text-gray-900 mb-1">${formattedKey}</h5>
                        <div class="text-xs text-gray-700 leading-relaxed" style="word-break: keep-all; hyphens: none;">${formattedValue}</div>
                    </div>
                `;
            }).join('');
        }

        // Update progress bar
        function updateProgress() {
            const currentIndex = sections.findIndex(s => s.id === currentSection);
            const progress = ((currentIndex + 1) / sections.length) * 100;
            document.getElementById('progress-indicator').style.width = `${progress}%`;
        }

        // Create key metrics
        function createKeyMetrics(transactionsData) {
            // Calculate metrics from transaction data
            const credits = transactionsData.transactions.filter(t => t.direction === 'Credit');
            const debits = transactionsData.transactions.filter(t => t.direction === 'Debit');
            
            const totalInflow = credits.reduce((sum, t) => sum + parseInt(t.amount, 10), 0);
            const totalOutflow = debits.reduce((sum, t) => sum + parseInt(t.amount, 10), 0);
            const netFlow = totalInflow - totalOutflow;
            const totalTransactions = transactionsData.transactions.reduce((sum, t) => sum + parseInt(t.count, 10), 0);
            
            const metrics = [
                {
                    label: 'Total Inflow',
                    value: formatCurrency(totalInflow),
                        icon: 'arrow-down-right',
                    color: 'success',
                    change: `${credits.length} types`
                    },
                    {
                    label: 'Total Outflow', 
                    value: formatCurrency(totalOutflow),
                        icon: 'arrow-up-right',
                    color: 'danger',
                    change: `${debits.length} types`
                    },
                    {
                    label: 'Net Flow',
                    value: formatCurrency(Math.abs(netFlow)),
                        icon: 'trending-up',
                    color: netFlow >= 0 ? 'success' : 'danger',
                    change: netFlow >= 0 ? 'Positive' : 'Negative'
                },
                {
                    label: 'Total Transactions',
                    value: formatNumber(totalTransactions),
                    icon: 'hash',
                    color: 'primary',
                    change: `${transactionsData.transactions.length} categories`
                }
            ];
            
                                  const container = document.getElementById('key-metrics');
             container.innerHTML = metrics.map(metric => `
                 <div class="metric-card p-2 rounded-lg">
                     <div class="flex items-center justify-between mb-1">
                         <div class="w-6 h-6 bg-${metric.color}-100 rounded-md flex items-center justify-center">
                             <i data-lucide="${metric.icon}" class="w-3 h-3 text-${metric.color}-600"></i>
                         </div>
                         <span class="text-xs font-medium text-${metric.color}-600 bg-${metric.color}-50 px-1 py-0.5 rounded-full">
                             ${metric.change}
                         </span>
                     </div>
                     <h3 class="text-xs font-medium text-gray-600 mb-1">${metric.label}</h3>
                     <p class="text-sm font-bold text-gray-900 font-mono">${metric.value}</p>
                 </div>
             `).join('');
            
            createIcons();
        }

        // Create transactions Sankey flow
        function createTransactionsSankey(data) {
            const container = document.getElementById('transactions-content');
            
            // Create container with key metrics and Sankey diagram
            container.innerHTML = `
                                 <!-- Key Metrics -->
                 <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-2 mb-2" id="key-metrics">
                     <!-- Will be populated by createKeyMetrics -->
                 </div>
                
                <!-- Sankey Diagram -->
                <div class="bg-white rounded-xl shadow-sm">
                    <div id="sankey-chart" style="height: 300px; width: 100%;"></div>
                </div>
                
                                 <!-- Transaction Usage Dictionary Table -->
                <div class="mt-4">
                    <div class="bg-white rounded-xl shadow-sm p-4">
                        <h3 class="text-lg font-semibold text-gray-900 mb-3">Transaction Usage Dictionary</h3>
                        <div id="trans-usage-dict-table" class="overflow-x-auto">
                            <!-- Will be populated dynamically -->
                        </div>
                         <details class="transaction-details-toggle mt-6 rounded-xl border border-purple-100 shadow-sm hover:shadow-lg hover:shadow-purple-200/50 transition-all duration-300 overflow-hidden bg-gradient-to-br from-white via-purple-50/30 to-blue-50/30">
                             <summary class="cursor-pointer px-6 py-3 bg-gradient-to-r from-purple-100/80 via-blue-100/80 via-indigo-100/80 to-purple-100/80 hover:from-purple-200 hover:via-blue-200 hover:via-indigo-200 hover:to-purple-200 transition-all duration-300 flex items-center justify-center group border-b border-purple-200/50">
                                 <span class="text-xs font-medium text-purple-700 hover:text-indigo-800 transition-colors duration-300 tracking-wide uppercase letter-spacing-widest drop-shadow-sm">
                                     Show Transaction Usage Details
                                 </span>
                             </summary>
                             <div class="px-6 py-4 bg-gradient-to-b from-purple-50/40 via-blue-50/40 to-white" id="transaction-usage-detail-content">
                                 <!-- Will be populated dynamically -->
                             </div>
                         </details>
                     </div>
                 </div>
                `;

            // Prepare data for Sankey diagram
            const nodes = [];
            const links = [];
            let nodeIndex = 0;
            const nodeMap = {};

            // Separate credit and debit transactions
            const credits = data.transactions.filter(t => t.direction === 'Credit');
            const debits = data.transactions.filter(t => t.direction === 'Debit');

            // Layer 1: Inflow types (Credits)
            credits.forEach(transaction => {
                const sourceName = `${transaction.direction} ${transaction.category}`;
                if (!nodeMap[sourceName]) {
                    nodeMap[sourceName] = nodeIndex++;
                    nodes.push({
                        node: nodeMap[sourceName],
                        label: sourceName,
                        color: 'rgba(34, 197, 94, 0.8)' // Green for inflows
                    });
                }
            });

            // Layer 2: Central Pool
            const poolName = 'Central Pool';
            nodeMap[poolName] = nodeIndex++;
            nodes.push({
                node: nodeMap[poolName],
                label: poolName,
                color: 'rgba(59, 130, 246, 0.8)' // Blue for pool
            });

            // Layer 3: Outflow types (Debits)
            debits.forEach(transaction => {
                const targetName = `${transaction.direction} ${transaction.category}`;
                if (!nodeMap[targetName]) {
                    nodeMap[targetName] = nodeIndex++;
                    nodes.push({
                        node: nodeMap[targetName],
                        label: targetName,
                        color: 'rgba(239, 68, 68, 0.8)' // Red for outflows
                    });
                }
            });

            // Create links: Inflows  Pool
            credits.forEach(transaction => {
                const sourceName = `${transaction.direction} ${transaction.category}`;
                links.push({
                    source: nodeMap[sourceName],
                    target: nodeMap[poolName],
                    value: transaction.amount / 1000000, // Convert to millions for better visualization
                    label: `${formatCurrency(transaction.amount)} (${transaction.pct})`
                });
            });

            // Create links: Pool  Outflows
            debits.forEach(transaction => {
                const targetName = `${transaction.direction} ${transaction.category}`;
                links.push({
                    source: nodeMap[poolName],
                    target: nodeMap[targetName],
                    value: transaction.amount / 1000000, // Convert to millions for better visualization
                    label: `${formatCurrency(transaction.amount)} (${transaction.pct})`
                });
            });

            // Create Plotly Sankey diagram
            const sankeyData = {
                type: "sankey",
                orientation: "h",
                arrangement: "freeform",
                node: {
                    pad: 20,
                    thickness: 35,
                    line: {
                        color: "#374151",
                        width: 1
                    },
                    label: nodes.map(n => n.label === 'Central Pool' ? '' : n.label),
                    color: nodes.map(n => n.color),
                    hovertemplate: '<b>%{label}</b><br>Total: %{value:.1f}M<extra></extra>'
                },
                link: {
                    source: links.map(l => l.source),
                    target: links.map(l => l.target),
                    value: links.map(l => l.value),
                    label: links.map(l => l.label),
                    color: links.map((l, i) => {
                        // Color links based on whether they're inflow or outflow
                        const isInflow = l.target === nodeMap[poolName];
                        return isInflow ? 'rgba(34, 197, 94, 0.4)' : 'rgba(239, 68, 68, 0.4)';
                    }),
                    line: {
                        color: 'rgba(0, 0, 0, 0.3)',
                        width: 1
                    },
                    hovertemplate: '<b>%{label}</b><extra></extra>'
                }
            };

            const layout = {
                font: { size: 12, color: '#374151' },
                margin: { l: 0, r: 0, t: 10, b: 10 },
                paper_bgcolor: 'white',
                plot_bgcolor: 'white',
                width: null,
                height: 280,
                autosize: true
            };

            const config = {
                displayModeBar: true,
                displaylogo: false,
                modeBarButtonsToRemove: ['pan2d', 'select2d', 'lasso2d', 'autoScale2d'],
                responsive: true,
                toImageButtonOptions: {
                    format: 'png',
                    filename: 'transaction_flow',
                    height: 400,
                    width: 1400,
                    scale: 1
                }
            };

            // Wait for DOM to be ready, then render the Sankey diagram
            setTimeout(() => {
                Plotly.newPlot('sankey-chart', [sankeyData], layout, config).then(() => {
                    // Force a resize after initial render to ensure proper sizing
                    setTimeout(() => {
                        Plotly.Plots.resize('sankey-chart');
                    }, 50);
                });
            }, 50);

            // Add resize handler for responsiveness
            window.addEventListener('resize', () => {
                Plotly.Plots.resize('sankey-chart');
            });

            

            // Load transaction usage dictionary data
            loadTransactionUsageDict();

            createIcons();
        }

        // Mobile menu functionality
        function toggleMobileMenu(show = null) {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('mobile-overlay');
            
            const isShown = !sidebar.classList.contains('-translate-x-full');
            const shouldShow = show !== null ? show : !isShown;
            
            if (shouldShow) {
                sidebar.classList.remove('-translate-x-full');
                overlay.classList.remove('hidden');
            } else {
                sidebar.classList.add('-translate-x-full');
                overlay.classList.add('hidden');
            }
        }

        // Initialize dashboard
        async function initDashboard() {
            try {
                // First load available accounts
                await loadAvailableAccounts();
                
                // Create basic UI structure
                createNavigation();
                
                // Create horizontal tabs
                await createHorizontalTabs();
                
                // Initialize features
                initEventListeners();
                
                // Set up scroll sync
                setupScrollSync();
                
                // Update initial account status
                updateAccountStatus();
                
            } catch (error) {
                console.error('Error initializing dashboard:', error);
                showError(error.message);
            }
        }

        // Set up scroll sync functionality
        function setupScrollSync() {
            const mainElement = document.querySelector('main');
            let scrollTimeout;
            
            // Debounced scroll handler
            const debouncedScrollHandler = () => {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    updateActiveNavigation();
                }, 50); // 50ms delay
            };
            
            // Add scroll event listener to main content
            mainElement.addEventListener('scroll', debouncedScrollHandler);
            
            // Also listen for window scroll events (for mobile)
            window.addEventListener('scroll', debouncedScrollHandler);
            
            // Initial update
            updateActiveNavigation();
        }

        // Test API endpoints to debug issues
        async function testAPIEndpoints() {
            console.log('Testing API endpoints...');
            
            try {
                const endpoints = ['public-info', 'public-address'];
                
                for (const endpoint of endpoints) {
                    console.log(`\n--- Testing ${endpoint} ---`);
                    const data = await fetchApiData(endpoint);
                    console.log(`${endpoint} response:`, data);
                    
                    if (data && Object.keys(data).length > 0) {
                        console.log(`${endpoint} has data with keys:`, Object.keys(data));
                    } else {
                        console.log(`${endpoint} has no data or empty response`);
                    }
                }
            } catch (error) {
                console.error('Error testing API endpoints:', error);
            }
        }

        // Refresh company info data
        async function refreshCompanyInfo() {
            if (!selectedAccount) {
                alert('Please select an account first');
                return;
            }
            
            console.log('Refreshing company info for account:', selectedAccount);
            
            try {
                // Fetch fresh data for the selected account
                const [publicInfoData, publicAddressData] = await Promise.all([
                    fetchApiData('public-info', selectedAccount),
                    fetchApiData('public-address', selectedAccount)
                ]);
                
                // Update global data
                apiData.publicInfo = publicInfoData;
                apiData.publicAddress = publicAddressData;
                
                // Update the content
                const publicInfoContainer = document.getElementById('public-info-content');
                if (publicInfoContainer) {
                    publicInfoContainer.innerHTML = createPublicInfoContent();
                }
                
                console.log('Company info refreshed successfully for account:', selectedAccount);
            } catch (error) {
                console.error('Error refreshing company info:', error);
                alert('Failed to refresh company info. Check console for details.');
            }
        }

        // Load transaction usage dictionary data
        async function loadTransactionUsageDict() {
            if (!selectedAccount) {
                console.warn('No account selected for transaction usage dictionary');
                return;
            }
            
            try {
                console.log('Loading transaction usage dictionary data for account:', selectedAccount);
                const data = await fetchApiData('transactions_usage_dict', selectedAccount);
                
                if (!data || Object.keys(data).length === 0) {
                    document.getElementById('trans-usage-dict-table').innerHTML = `
                        <div class="text-center py-8 text-gray-500">
                            <i data-lucide="database" class="w-12 h-12 mx-auto mb-3 text-gray-300"></i>
                            <p>No transaction usage dictionary data available for account ${selectedAccount}</p>
                        </div>
                    `;
                    return;
                }

                                     // Create table from the data
                     const tableHtml = createTransactionUsageDictTable(data);
                     document.getElementById('trans-usage-dict-table').innerHTML = tableHtml;
                     
                     // Recreate icons for the new content
                     createIcons();
                
                console.log('Transaction usage dictionary table created successfully for account:', selectedAccount);
            } catch (error) {
                console.error('Error loading transaction usage dictionary:', error);
                document.getElementById('trans-usage-dict-table').innerHTML = `
                    <div class="text-center py-8 text-red-500">
                        <i data-lucide="alert-circle" class="w-12 h-12 mx-auto mb-3 text-red-300"></i>
                        <p>Error loading transaction usage dictionary data for account ${selectedAccount}</p>
                        <p class="text-sm text-gray-500 mt-2">${error.message}</p>
                    </div>
                `;
                createIcons();
            }
        }

        // Populate transaction usage detail content
        function populateTransactionUsageDetail() {
            const container = document.getElementById('transaction-usage-detail-content');
            if (!container) {
                console.warn('Transaction usage detail container not found');
                return;
            }

            if (!apiData.transUsageDetailDict || (!Array.isArray(apiData.transUsageDetailDict) && typeof apiData.transUsageDetailDict !== 'object')) {
                container.innerHTML = `
                    <div class="text-center py-8 text-gray-500">
                        <i data-lucide="database" class="w-12 h-12 mx-auto mb-3 text-gray-300"></i>
                        <p>No transaction usage detail data available</p>
                    </div>
                `;
                return;
            }

            console.log('Populating transaction usage detail data:', apiData.transUsageDetailDict);
            container.innerHTML = createTransactionUsageDetailTable(apiData.transUsageDetailDict);

            // Re-initialize Lucide icons
            lucide.createIcons();
        }

        // Create transaction usage dictionary table - Simple and cross-compatible
        function createTransactionUsageDictTable(data) {
            if (typeof data === 'string') {
                return '<div style="background: #f9fafb; border-radius: 8px; padding: 16px;"><div style="font-size: 12px; color: #374151; line-height: 1.6;">' + formatText(data) + '</div></div>';
            }

            if (typeof data === 'object' && data !== null) {
                if (Array.isArray(data)) {
                    if (data.length === 0) {
                        return '<div style="text-align: center; padding: 32px 16px; color: #6b7280;"><p>No items available</p></div>';
                    }

                     const firstItem = data[0];
                     if (!firstItem || typeof firstItem !== 'object') {
                        return '<div style="text-align: center; padding: 32px 16px; color: #6b7280;"><p>Invalid data format</p></div>';
                    }

                    // Use all available columns from the data
                    const availableKeys = Object.keys(firstItem);
                    
                    console.log('=== TRANSACTION USAGE DICT TABLE DEBUG ===');
                    console.log('First item data:', firstItem);
                    console.log('Available keys in data:', availableKeys);
                    console.log('=== END DEBUG ===');
                    
                    // Create simple table rows with click handlers
                    const tableRows = data.map(function(item) {
                        const rowCells = availableKeys.map(function(key) {
                             const value = item[key];
                             let formattedValue;
                             
                             if (typeof value === 'string') {
                                 formattedValue = formatText(value);
                             } else if (typeof value === 'number') {
                                // Format currency columns (trans_am, amount, value, etc.)
                                if (key === 'trans_am' || key.toLowerCase().includes('trans_am') || key.toLowerCase().includes('trans am') || 
                                    key.toLowerCase().includes('amount') || key.toLowerCase().includes('value') || key.toLowerCase().includes('am')) {
                                    // Offline-compatible currency formatting
                                    const roundedValue = Math.round(value);
                                    formattedValue = '$' + roundedValue.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                                 } else {
                                    // Offline-compatible number formatting
                                    const roundedValue = Math.round(value);
                                    formattedValue = roundedValue.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                                 }
                             } else if (typeof value === 'object' && value !== null) {
                                formattedValue = JSON.stringify(value);
                             } else {
                                 formattedValue = String(value);
                             }

                            return '<td style="padding: 8px 16px; font-size: 12px; color: #374151; border: 1px solid #e5e7eb; background-color: white;">' + formattedValue + '</td>';
                         }).join('');

                        // Get the transaction type and filter parameters for the API call
                        const transactionType = item.category || item.transaction_type || 'unknown';
                        const category = item.category || '';
                        const direction = item.direction || '';
                        const userCategory = item.usage_category || '';
                        const clickHandler = `onclick="showTransactionDetailModal('${transactionType}', '${category}', '${direction}', '${userCategory}')"`;
                        
                        return `<tr ${clickHandler} style="cursor: pointer;" onmouseover="this.style.backgroundColor='#f3f4f6'" onmouseout="this.style.backgroundColor='white'">${rowCells}</tr>`;
                     }).join('');

                    // Create sortable headers preserving API column order
                    const tableHeaders = availableKeys.map(function(key) {
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, function(l) { return l.toUpperCase(); });
                        return '<th data-sortable="true" style="padding: 8px 16px; font-size: 12px; font-weight: bold; color: #374151; border: 1px solid #e5e7eb; background-color: #f3f4f6; cursor: pointer; user-select: none;" onmouseover="this.style.backgroundColor=\'#e5e7eb\'" onmouseout="this.style.backgroundColor=\'#f3f4f6\'">' + formattedKey + '<span class="sort-icon"></span></th>';
                    }).join('');

                    return '<div style="background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow: hidden;"><table style="width: 100%; border-collapse: collapse;" id="trans-usage-table"><thead><tr>' + tableHeaders + '</tr></thead><tbody>' + tableRows + '</tbody></table></div>';
                } else {
                    // Handle non-array objects
                    const entries = Object.entries(data);
                    if (entries.length === 0) {
                        return '<div style="text-align: center; padding: 32px 16px; color: #6b7280;"><p>No data available</p></div>';
                    }

                    const tableRows = entries.map(function([key, value]) {
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, function(l) { return l.toUpperCase(); });
                        let formattedValue;
                        
                        if (typeof value === 'string') {
                            formattedValue = formatText(value);
                        } else if (typeof value === 'number') {
                            formattedValue = value.toLocaleString('en-US');
                        } else if (typeof value === 'object' && value !== null) {
                            formattedValue = JSON.stringify(value);
                        } else {
                            formattedValue = String(value);
                        }

                        // Use the key as transaction type for non-array objects
                        const transactionType = key;
                        const category = key;
                        const direction = '';
                        const userCategory = '';
                        const clickHandler = `onclick="showTransactionDetailModal('${transactionType}', '${category}', '${direction}', '${userCategory}')"`;
                        
                        return `<tr ${clickHandler} style="cursor: pointer;" onmouseover="this.style.backgroundColor='#f3f4f6'" onmouseout="this.style.backgroundColor='white'"><td style="padding: 8px 16px; font-size: 12px; font-weight: bold; color: #374151; border: 1px solid #e5e7eb; background-color: #f9fafb;">${formattedKey}</td><td style="padding: 8px 16px; font-size: 12px; color: #374151; border: 1px solid #e5e7eb; background-color: white;">${formattedValue}</td></tr>`;
                    }).join('');

                    return '<table style="width: 100%; border-collapse: collapse;"><thead><tr><th data-sortable="true" style="padding: 8px 16px; font-size: 12px; font-weight: bold; color: #374151; border: 1px solid #e5e7eb; background-color: #f3f4f6; cursor: pointer; user-select: none;" onmouseover="this.style.backgroundColor=\'#e5e7eb\'" onmouseout="this.style.backgroundColor=\'#f3f4f6\'">Key<span class="sort-icon"></span></th><th data-sortable="true" style="padding: 8px 16px; font-size: 12px; font-weight: bold; color: #374151; border: 1px solid #e5e7eb; background-color: #f3f4f6; cursor: pointer; user-select: none;" onmouseover="this.style.backgroundColor=\'#e5e7eb\'" onmouseout="this.style.backgroundColor=\'#f3f4f6\'">Value<span class="sort-icon"></span></th></tr></thead><tbody>' + tableRows + '</tbody></table>';
                }
            }

            return '<div style="text-align: center; padding: 32px 16px; color: #6b7280;"><p>Invalid data format</p></div>';
        }

        // Create transaction usage detail table
        function createTransactionUsageDetailTable(data) {
            if (typeof data === 'string') {
                return '<div style="background: #f9fafb; border-radius: 8px; padding: 16px;"><div style="font-size: 12px; color: #374151; line-height: 1.6;">' + formatText(data) + '</div></div>';
            }

            if (typeof data === 'object' && data !== null) {
                if (Array.isArray(data)) {
                    if (data.length === 0) {
                        return '<div style="text-align: center; padding: 32px 16px; color: #6b7280;"><p>No transaction usage details available</p></div>';
                    }

                    const firstItem = data[0];
                    if (typeof firstItem !== 'object' || firstItem === null) {
                        return '<div style="text-align: center; padding: 32px 16px; color: #6b7280;"><p>Invalid data format</p></div>';
                    }

                    // Use all available columns from the data
                    const availableKeys = Object.keys(firstItem);

                    // Create table rows
                    const tableRows = data.map(function(item, index) {
                        const rowCells = availableKeys.map(function(key) {
                            let value = item[key];
                            let formattedValue = '';
                            
                            if (value === null || value === undefined) {
                                formattedValue = '-';
                            } else if (typeof value === 'object') {
                                formattedValue = JSON.stringify(value);
                            } else {
                                formattedValue = String(value);
                            }

                            const bgColor = index % 2 === 0 ? 'white' : '#f9fafb';
                            return '<td style="padding: 8px 16px; font-size: 12px; color: #374151; border: 1px solid #e5e7eb; background-color: ' + bgColor + ';">' + formattedValue + '</td>';
                        }).join('');

                        return '<tr>' + rowCells + '</tr>';
                    }).join('');

                    // Create sortable table headers preserving API column order
                    const tableHeaders = availableKeys.map(function(key) {
                        const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        return '<th data-sortable="true" style="padding: 8px 16px; font-size: 12px; font-weight: bold; color: #374151; border: 1px solid #e5e7eb; background-color: #f3f4f6; cursor: pointer; user-select: none;" onmouseover="this.style.backgroundColor=\'#e5e7eb\'" onmouseout="this.style.backgroundColor=\'#f3f4f6\'">' + formattedKey + '<span class="sort-icon"></span></th>';
                    }).join('');

                    return '<div style="background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow-x: scroll; max-height: 400px; overflow-y: scroll;" class="modal-scrollbar"><table style="width: 100%; border-collapse: collapse;" id="trans-usage-detail-table"><thead><tr>' + tableHeaders + '</tr></thead><tbody>' + tableRows + '</tbody></table></div>';
                }
            }

            return '<div style="text-align: center; padding: 32px 16px; color: #6b7280;"><p>Invalid data format</p></div>';
        }

        // Create UTR table
        function createUTRTable(dataOverride = null) {
            const utrData = dataOverride || apiData.utrInfo;
            console.log('Creating UTR table with data:', utrData);
            
            if (!utrData || !Array.isArray(utrData) || utrData.length === 0) {
                console.log('No UTR data available');
                return '<div style="text-align: center; padding: 16px; color: #6b7280;"><p>No UTR information available</p></div>';
            }

            const firstItem = utrData[0];
            if (!firstItem || typeof firstItem !== 'object') {
                console.log('Invalid UTR data format:', firstItem);
                return '<div style="text-align: center; padding: 16px; color: #6b7280;"><p>Invalid UTR data format</p></div>';
            }

            // Use all available columns from the data
            const availableKeys = Object.keys(utrData[0]);
            
            // Create table rows with click functionality
            const tableRows = utrData.map(function(item, index) {
                console.log('Processing UTR item:', item, 'for index:', index);
                const rowCells = availableKeys.map(function(key) {
                    let value = item[key];
                    
                    // Handle missing columns gracefully
                    if (value === undefined || value === null) {
                        value = '-';
                    }
                    
                    console.log('UTR key:', key, 'value:', value);
                    let formattedValue;
                    
                    if (typeof value === 'string') {
                        formattedValue = formatText(value);
                    } else if (typeof value === 'number') {
                        formattedValue = value.toLocaleString('en-US');
                    } else if (typeof value === 'object' && value !== null) {
                        formattedValue = JSON.stringify(value);
                    } else {
                        formattedValue = String(value);
                    }

                    // Alternate row colors for better readability
                    const bgColor = index % 2 === 0 ? 'white' : '#f9fafb';
                    
                    return '<td style="padding: 10px 14px; font-size: 13px; color: #374151; border: 1px solid #e5e7eb; background-color: ' + bgColor + '; text-align: left; vertical-align: top;">' + formattedValue + '</td>';
                }).join('');

                // Get account number for click functionality
                const accountNumber = item['Account Number'] || item['account_number'] || item['accountNumber'];
                const rowId = `utr-row-${index}`;
                
                return '<tr id="' + rowId + '" data-account="' + accountNumber + '" class="cursor-pointer hover:bg-blue-50 transition-colors border-l-4 border-l-transparent hover:border-l-blue-500" onclick="highlightNodeInGraph(\'' + accountNumber + '\')" title="Click to highlight corresponding node in graph">' + rowCells + '</tr>';
            }).join('');

            // Create sortable table headers with all available columns preserving API order
            const tableHeaders = availableKeys.map(function(key) {
                let formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, function(l) { return l.toUpperCase(); });
                
                return '<th data-sortable="true" style="padding: 10px 14px; font-size: 13px; font-weight: bold; color: #374151; border: 1px solid #e5e7eb; background-color: white; text-align: left; cursor: pointer; user-select: none;" onmouseover="this.style.backgroundColor=\'#f3f4f6\'" onmouseout="this.style.backgroundColor=\'white\'">' + formattedKey + '<span class="sort-icon"></span></th>';
            }).join('');

            return '<div style="overflow-x: auto;"><table id="utr-table" style="width: 100%; border-collapse: collapse; font-size: 13px;"><thead><tr>' + tableHeaders + '</tr></thead><tbody>' + tableRows + '</tbody></table></div>';
        }

        // Function to filter table data based on current graph nodes
        function filterTableDataByGraph(tableData, graphNodes) {
            if (!tableData || !Array.isArray(tableData) || !graphNodes || !Array.isArray(graphNodes)) {
                return tableData || [];
            }
            
            // Create a set of node IDs for efficient lookup
            const nodeIds = new Set(graphNodes.map(node => node.id));
            
            // Filter table data to only include entries with account numbers that exist in the graph
            return tableData.filter(item => {
                const accountNumber = item['Account Number'] || item['account_number'] || item['accountNumber'];
                if (!accountNumber) return false;
                
                // Try different formatting variations
                const variations = [
                    accountNumber,
                    String(accountNumber).padStart(16, '0'), // Zero-padded to 16 digits
                    String(accountNumber).replace(/^0+/, ''), // Remove leading zeros
                ];
                
                return variations.some(variation => nodeIds.has(variation));
            });
        }

        // Function to update UTR table based on current graph
        function updateTablesForCurrentGraph(graphData) {
            if (!graphData || !graphData.nodes) {
                console.warn('No graph data available for table filtering');
                return;
            }
            
            console.log(`Table will show full data (no filtering) - graph has ${graphData.nodes.length} nodes`);
            
            // Always use full UTR data (no filtering)
            const fullUTR = apiData.utrInfo;
            console.log(`UTR showing full data: ${fullUTR?.length || 0} entries`);
            
            // Update UTR table with full data
            const utrContainer = document.querySelector('#high-cash-content .mt-4:first-child .bg-white div');
            if (utrContainer && fullUTR && fullUTR.length > 0) {
                utrContainer.innerHTML = createUTRTable(fullUTR);
            } else if (utrContainer) {
                utrContainer.innerHTML = '<div class="text-center text-gray-500 text-xs py-8">No UTR entries available</div>';
            }
        }

        // Function to show temporary message to user
        function showTemporaryMessage(message) {
            // Remove any existing message
            const existingMessage = document.getElementById('temp-message');
            if (existingMessage) {
                existingMessage.remove();
            }
            
            // Create message element
            const messageEl = document.createElement('div');
            messageEl.id = 'temp-message';
            messageEl.className = 'fixed top-4 right-4 bg-yellow-100 border border-yellow-400 text-yellow-800 px-4 py-3 rounded-lg shadow-lg z-50 max-w-sm';
            messageEl.innerHTML = `
                <div class="flex items-start">
                    <i data-lucide="info" class="w-5 h-5 mr-2 flex-shrink-0 mt-0.5"></i>
                    <div class="text-sm">${message}</div>
                </div>
            `;
            
            // Add to body
            document.body.appendChild(messageEl);
            
            // Create icons for the message
            createIcons();
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (messageEl && messageEl.parentNode) {
                    messageEl.remove();
                }
            }, 5000);
        }

        // Function to highlight node in D3 graph when UTR table row is clicked
        function highlightNodeInGraph(accountNumber) {
            console.log('Highlighting node for account:', accountNumber);
            
            // Check if this row is already highlighted
            const utrRow = document.querySelector(`#utr-table tr[data-account="${accountNumber}"]`);
            const isAlreadyHighlighted = utrRow && utrRow.classList.contains('bg-blue-100');
            
            if (isAlreadyHighlighted) {
                // If already highlighted, clear all highlights
                console.log('Row already highlighted, clearing highlights');
                clearAllHighlights();
                return;
            }
            
            // Clear any existing highlights first
            clearAllHighlights();
            
            // Find the node in the graph data
            if (!apiData.graph || !apiData.graph.nodes) {
                console.warn('No graph data available');
                return;
            }
            
            const targetNode = apiData.graph.nodes.find(node => node.id === accountNumber);
            if (!targetNode) {
                console.warn('Node not found for account:', accountNumber);
                return;
            }
            
            // Check if we're in subgraph mode and if the node exists in current graph data
            if (window.currentGraphData && window.currentGraphData.isSubgraph) {
                // For true subgraph, check if the node exists in the current subgraph data
                const nodeExists = window.currentGraphData.nodes.some(node => node.id === accountNumber);
                if (!nodeExists) {
                    console.warn(`Node ${accountNumber} is not in current subgraph`);
                    // Still highlight the table row, but show a message that the node is not visible
                    highlightTableRow(accountNumber);
                    
                    // Show a temporary message to the user
                    showTemporaryMessage(`Account ${accountNumber} is not in the current subgraph view. Switch to Full Graph to see this node.`);
                    return;
                }
                console.log(`Node ${accountNumber} exists in subgraph, highlighting...`);
            } else if (window.currentGraphData && window.currentGraphData.subgraphNodeIds) {
                // Legacy subgraph mode with visibility control (fallback)
                const isNodeVisible = window.currentGraphData.subgraphNodeIds.has(accountNumber);
                if (!isNodeVisible) {
                    console.warn(`Node ${accountNumber} is not visible in current subgraph view`);
                    // Still highlight the table row, but show a message that the node is not visible
                    highlightTableRow(accountNumber);
                    
                    // Show a temporary message to the user
                    showTemporaryMessage(`Account ${accountNumber} is not visible in the current subgraph view. Switch to Full Graph to see this node.`);
                    return;
                }
                console.log(`Node ${accountNumber} is visible in subgraph, highlighting...`);
            }
            
            // Highlight the clicked row in both tables
            highlightTableRow(accountNumber);
            
            // Highlight the corresponding node in the D3 graph
            highlightD3Node(accountNumber);
        }

        // Function to clear all highlights
        function clearAllHighlights() {
            // Clear UTR table highlights
            document.querySelectorAll('#utr-table tr').forEach(row => {
                row.classList.remove('bg-blue-100', 'ring-2', 'ring-blue-500');
            });
            
            // Clear D3 graph/tree highlights and restore all nodes to 80% opacity (if visualization exists)
            if (window.currentSvg) {
                const svg = d3.select(window.currentSvg);
                svg.selectAll('circle').attr('stroke-width', 1.5).attr('opacity', 0.8);
                svg.selectAll('line').attr('stroke-width', 1.5).attr('stroke-opacity', 0.3);
                // Hide all relationship labels
                svg.selectAll('.link-label').attr('opacity', 0);
            }
        }

        // Function to highlight table rows (UTR)
        function highlightTableRow(accountNumber) {
            // Highlight UTR table rows
            const utrRows = document.querySelectorAll('#utr-table tr[data-account]');
            utrRows.forEach(row => {
                if (row.getAttribute('data-account') === accountNumber) {
                    row.classList.add('bg-blue-100', 'ring-2', 'ring-blue-500');
                } else {
                    row.classList.remove('bg-blue-100', 'ring-2', 'ring-blue-500');
                }
            });
        }

        // Function to show node details (works for all graph types)
        function showNodeDetails(d) {
            console.log('Showing node details for:', d);
            
            // Extract node data based on format (tree vs graph)
            const nodeData = d.data || d; // Tree format has d.data, graph format is direct
            const nodeId = nodeData.id;
            const nodeLabel = nodeData.label || nodeId;
            const nodeColor = nodeData.color || '#666';
            
            // Log detailed information
            console.log(`Node Details:
                ID: ${nodeId}
                Label: ${nodeLabel}
                Color: ${nodeColor}
                Type: ${d.data ? 'Tree Node' : 'Graph Node'}`);
            
            // You can extend this to show a modal, tooltip, or side panel
            // For now, we'll just highlight the node and its connections
            highlightNodeConnections(d);
        }

        // Function to highlight node connections with edge relationships and colors
        function highlightNodeConnections(d) {
            if (!window.currentSvg) {
                console.warn('D3 graph not yet rendered');
                return;
            }
            
            const svg = d3.select(window.currentSvg);
            const nodeData = d.data || d; // Handle both tree and graph formats
            const nodeId = nodeData.id;
            
            // Dim all elements first
            svg.selectAll('circle').attr('opacity', 0.2);
            svg.selectAll('line').attr('stroke-opacity', 0.1).attr('stroke-width', 1);
            svg.selectAll('.tree-label, text').attr('opacity', 0.2);
            svg.selectAll('.link-label').attr('opacity', 0);
            
            // Highlight the selected node
            svg.selectAll('circle').filter(node => {
                const currentNodeData = node.data || node;
                return currentNodeData.id === nodeId;
            }).attr('opacity', 1).attr('stroke-width', 4).attr('stroke', '#ff6b6b');
            
            // Highlight connected edges and their relationships
            svg.selectAll('line').each(function(linkData) {
                const link = d3.select(this);
                const sourceData = linkData.source.data || linkData.source;
                const targetData = linkData.target.data || linkData.target;
                const sourceId = sourceData.id;
                const targetId = targetData.id;
                
                // Check if this link connects to our selected node
                if (sourceId === nodeId || targetId === nodeId) {
                    // Get the original color for this edge
                    let edgeColor = '#ff6b6b'; // fallback color
                    
                    // For tree format, use the same logic as the original tree links
                    if (linkData.source.data && linkData.target.data) {
                        // This is tree format - get color from current stroke attribute (which was set using linkColors map)
                        edgeColor = link.attr('stroke') || '#ff6b6b';
                    } else {
                        // This is graph format - use the color from linkData
                        edgeColor = linkData.color || '#ff6b6b';
                    }
                    
                    // Highlight the connected edge with its original relationship color
                    link.attr('stroke-opacity', 0.8)
                        .attr('stroke-width', 3)
                        .attr('stroke', edgeColor);
                    
                    // Highlight connected nodes
                    svg.selectAll('circle').filter(node => {
                        const currentNodeData = node.data || node;
                        return currentNodeData.id === sourceId || currentNodeData.id === targetId;
                    }).attr('opacity', 1);
                    
                    // Show relationship labels for connected edges
                    svg.selectAll('.link-label').filter(labelData => {
                        const labelSourceData = labelData.source.data || labelData.source;
                        const labelTargetData = labelData.target.data || labelData.target;
                        return (labelSourceData.id === sourceId && labelTargetData.id === targetId) ||
                               (labelSourceData.id === targetId && labelTargetData.id === sourceId);
                    }).attr('opacity', 1);
                }
            });
            
            // Highlight node labels for connected nodes
            svg.selectAll('.tree-label, text').filter(function(labelData) {
                if (!labelData) return false;
                const labelNodeData = labelData.data || labelData;
                // Check if this label belongs to the selected node or connected nodes
                let isConnected = labelNodeData.id === nodeId;
                
                if (!isConnected) {
                    // Check if this node is connected to our selected node
                    svg.selectAll('line').each(function(linkData) {
                        const sourceData = linkData.source.data || linkData.source;
                        const targetData = linkData.target.data || linkData.target;
                        if ((sourceData.id === nodeId && targetData.id === labelNodeData.id) ||
                            (targetData.id === nodeId && sourceData.id === labelNodeData.id)) {
                            isConnected = true;
                        }
                    });
                }
                
                return isConnected;
            }).attr('opacity', 1);
            
            console.log(`Highlighted connections for node: ${nodeId}`);
        }

        // Function to reset all highlighting
        function resetHighlighting() {
            if (!window.currentSvg) {
                console.warn('D3 graph not yet rendered');
                return;
            }
            
            const svg = d3.select(window.currentSvg);
            
            // Reset all elements to their default state
            svg.selectAll('circle').attr('opacity', 0.8).attr('stroke-width', 1.5).attr('stroke', '#333');
            svg.selectAll('line').attr('stroke-opacity', 0.3).attr('stroke-width', 1.5);
            svg.selectAll('.tree-label, text').attr('opacity', 1);
            svg.selectAll('.link-label').attr('opacity', 0); // Keep relationship labels hidden by default
        }

        // Function to highlight D3 node (works for both graph and tree)
        function highlightD3Node(accountNumber) {
            if (!window.currentSvg) {
                console.warn('D3 graph not yet rendered');
                return;
            }
            
            const svg = d3.select(window.currentSvg);
            
            // Set all nodes to 20% opacity (dimming effect)
            svg.selectAll('circle').attr('opacity', 0.2);
            
            // Find and highlight the target node (try both graph and tree formats)
            let targetNode = svg.selectAll('circle').filter(d => d.id === accountNumber); // Graph format
            if (targetNode.size() === 0) {
                targetNode = svg.selectAll('circle').filter(d => d.data && d.data.id === accountNumber); // Tree format
            }
            
            if (targetNode.size() > 0) {
                targetNode.attr('stroke-width', 4).attr('stroke', '#3b82f6').attr('opacity', 1);
                
                // Find neighbor nodes (directly connected) and set them to 80% opacity
                const neighborNodes = [];
                svg.selectAll('line').each(function(d) {
                    // Handle both graph and tree link formats
                    let sourceId, targetId;
                    if (d.source && d.target) {
                        // Graph format or tree with resolved references
                        sourceId = d.source.id || (d.source.data && d.source.data.id);
                        targetId = d.target.id || (d.target.data && d.target.data.id);
                    }
                    
                    if (sourceId === accountNumber) {
                        neighborNodes.push(targetId);
                    } else if (targetId === accountNumber) {
                        neighborNodes.push(sourceId);
                    }
                });
                
                // Set neighbor nodes to 80% opacity (handle both formats)
                svg.selectAll('circle').filter(d => {
                    const nodeId = d.id || (d.data && d.data.id);
                    return neighborNodes.includes(nodeId);
                }).attr('opacity', 0.8);
                
                // Highlight connected links (handle both formats)
                const connectedLinks = svg.selectAll('line').filter(d => {
                    let sourceId, targetId;
                    if (d.source && d.target) {
                        sourceId = d.source.id || (d.source.data && d.source.data.id);
                        targetId = d.target.id || (d.target.data && d.target.data.id);
                    }
                    return sourceId === accountNumber || targetId === accountNumber;
                });
                connectedLinks.attr('stroke-width', 3).attr('stroke-opacity', 0.8);
                
                // Show relationship labels for connected edges (handle both formats)
                svg.selectAll('.link-label').filter(d => {
                    let sourceId, targetId;
                    if (d.source && d.target) {
                        sourceId = d.source.id || (d.source.data && d.source.data.id);
                        targetId = d.target.id || (d.target.data && d.target.data.id);
                    }
                    return sourceId === accountNumber || targetId === accountNumber;
                }).attr('opacity', 1);
                
                console.log('Successfully highlighted node and connections for account:', accountNumber);
            } else {
                console.warn('Node not found in D3 graph for account:', accountNumber);
            }
        }

        // Sort table function
        // Generic table sorting function
        function sortTable(tableId, columnIndex, headerElement) {
            if (!tableId || !columnIndex || !headerElement) {
                console.warn('sortTable called with invalid parameters:', { tableId, columnIndex, headerElement });
                return;
            }
            
            const table = document.getElementById(tableId);
            if (!table) {
                console.warn('Table not found with ID:', tableId);
                return;
            }
            
            const tbody = table.querySelector('tbody');
            if (!tbody) {
                console.warn('Table body not found in table:', tableId);
                return;
            }
            
            const rows = Array.from(tbody.querySelectorAll('tr'));
            if (rows.length === 0) {
                console.warn('No rows found in table:', tableId);
                return;
            }
            
            // Get current sort direction and cycle through: none -> asc -> desc -> none
            const currentSort = headerElement.dataset.sort || 'none';
            let newSort;
            if (currentSort === 'none') {
                newSort = 'asc';
            } else if (currentSort === 'asc') {
                newSort = 'desc';
            } else {
                newSort = 'none';
            }
            
            // Reset all headers in this table
            table.querySelectorAll('th').forEach(th => {
                if (th.style) {
                    th.dataset.sort = 'none';
                    th.style.backgroundColor = 'transparent';
                }
                const sortIcon = th.querySelector('.sort-icon');
                if (sortIcon) {
                    sortIcon.innerHTML = '';
                }
            });
            
            // Update current header
            if (headerElement.style) {
                headerElement.dataset.sort = newSort;
                if (newSort === 'none') {
                    headerElement.style.backgroundColor = 'transparent';
                } else {
                    headerElement.style.backgroundColor = newSort === 'asc' ? '#f0fdf4' : '#eff6ff';
                }
            }
            
            // Only sort if not returning to default (none) state
            if (newSort !== 'none') {
                // Sort rows
                rows.sort((a, b) => {
                    const aCell = a.querySelector(`td:nth-child(${columnIndex})`);
                    const bCell = b.querySelector(`td:nth-child(${columnIndex})`);
                    
                    if (!aCell || !bCell) return 0;
                    
                    const aValue = aCell.textContent.replace(/\n\n+/g, '\n').replace(/[ ]*-[ ]*/g, '').trim().replace(/^\s+/, '');
                    const bValue = bCell.textContent.replace(/\n\n+/g, '\n').replace(/[ ]*-[ ]*/g, '').trim().replace(/^\s+/, '');
                    
                    // Try to parse as numbers
                    let aNum = parseFloat(aValue.replace(/[$,%]/g, ''));
                    let bNum = parseFloat(bValue.replace(/[$,%]/g, ''));
                    
                    // Check if both values are numbers
                    if (!isNaN(aNum) && !isNaN(bNum)) {
                        // Numeric sorting
                        return newSort === 'asc' ? aNum - bNum : bNum - aNum;
                    } else {
                        // String sorting
                        if (newSort === 'asc') {
                            return aValue.localeCompare(bValue);
                        } else {
                            return bValue.localeCompare(aValue);
                        }
                    }
                });
                
                // Reorder rows in DOM
                rows.forEach(row => tbody.appendChild(row));
            } else {
                // For 'none' state, we need to restore original order
                // We'll need to store the original order or re-fetch the data
                // For now, let's trigger a re-render of the table content
                const tableContainer = headerElement.closest('[id*="-content"], [id*="-table"]');
                if (tableContainer) {
                    // Try to find the parent container and trigger a refresh
                    const parentContainer = tableContainer.closest('.section-content');
                    if (parentContainer) {
                        // Find which section this table belongs to and refresh it
                        const sectionId = parentContainer.id;
                        if (sectionId === 'transactions-content') {
                            loadTransactionUsageDict();
                        } else if (sectionId === 'high-cash-content') {
                            updateTablesForCurrentGraph(apiData.graph);
                        } else if (sectionId === 'business-pattern-content') {
                            // Refresh customer info
                            const customerInfoContainer = document.getElementById('customer-info-content');
                            if (customerInfoContainer && apiData.customerInfo) {
                                customerInfoContainer.innerHTML = createCustomerInfoTable(apiData.customerInfo);
                            }
                        }
                    }
                }
            }
            
            // Update sort indicators
            updateSortIndicators(headerElement, newSort);
        }
        
        // Update sort indicators on headers
        function updateSortIndicators(headerElement, direction) {
            if (!headerElement) return;
            
            const sortIcon = headerElement.querySelector('.sort-icon');
            if (sortIcon) {
                if (direction === 'none') {
                    sortIcon.innerHTML = '';
                } else if (direction === 'asc') {
                    sortIcon.innerHTML = ' &#9650;';
                } else {
                    sortIcon.innerHTML = ' &#9660;';
                }
            }
        }
        
        // Legacy function for backward compatibility
        function sortTableLegacy(key, headerElement) {
            sortTable('trans-usage-table', getColumnIndex(key), headerElement);
        }
        
        // Get column index for a given key
        function getColumnIndex(key) {
            const table = document.getElementById('trans-usage-table');
            const headerRow = table.querySelector('thead tr');
            const headers = Array.from(headerRow.querySelectorAll('th'));
            
            for (let i = 0; i < headers.length; i++) {
                if (headers[i].dataset.key === key) {
                    return i + 1; // nth-child is 1-indexed
                }
            }
            return 1; // fallback
        }
        
        
        // Zoom functions for network graph
        function zoomIn() {
            const container = document.getElementById('network-graph');
            if (container && window.currentSvg) {
                const svg = d3.select(window.currentSvg);
                const currentTransform = d3.zoomTransform(svg.node());
                const newTransform = currentTransform.scale(currentTransform.k * 1.2);
                svg.transition().duration(300).call(window.currentZoom.transform, newTransform);
            }
        }
        
        function zoomOut() {
            const container = document.getElementById('network-graph');
            if (container && window.currentSvg) {
                const svg = d3.select(window.currentSvg);
                const currentTransform = d3.zoomTransform(svg.node());
                const newTransform = currentTransform.scale(currentTransform.k / 1.2);
                svg.transition().duration(300).call(window.currentZoom.transform, newTransform);
            }
        }

        // Create quick insights
        function createQuickInsights() {
            const container = document.getElementById('quick-insights');
            container.innerHTML = `
                <div class="card-elevated p-6">
                    <h3 class="text-lg font-semibold text-gray-900 mb-4 flex items-center">
                        <i data-lucide="trending-up" class="w-5 h-5 mr-2 text-primary-500"></i>
                        Transaction Summary
                    </h3>
                    <div class="space-y-3">
                        <div class="flex justify-between">
                            <span class="text-gray-600">Total Categories:</span>
                            <span class="font-semibold">${apiData.transactions.transactions.length}</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-600">Total Transactions:</span>
                            <span class="font-semibold">${formatNumber(apiData.transactions.transactions.reduce((sum, t) => sum + t.count, 0))}</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-600">Status:</span>
                            <span class="px-2 py-1 rounded-full text-xs font-medium bg-success-100 text-success-700">Active</span>
                        </div>
                    </div>
                </div>

                <div class="card-elevated p-6">
                    <h3 class="text-lg font-semibold text-gray-900 mb-4 flex items-center">
                        <i data-lucide="shield-check" class="w-5 h-5 mr-2 text-success-500"></i>
                        Cash Flow Health
                    </h3>
                    <div class="text-center">
                        <div class="w-16 h-16 bg-success-100 rounded-full flex items-center justify-center mx-auto mb-4">
                            <span class="text-2xl font-bold text-success-600">A+</span>
                        </div>
                        <p class="text-sm text-gray-600">Cash flow analysis available in the dashboard</p>
                    </div>
                </div>
            `;
            
            createIcons();
        }

        // Download HTML file with embedded CSS
        async function downloadHTML() {
            if (!selectedAccount) {
                alert('Please select an account first');
                return;
            }
            
            try {
                // Fetch the CSS content
                const cssResponse = await fetch('./static/css/output.css');
                const cssContent = await cssResponse.text();
                
                // Get the current HTML content
                let htmlContent = document.documentElement.outerHTML;
                
                // Replace the external CSS link with embedded CSS
                htmlContent = htmlContent.replace(
                    /<link href="\.\/static\/css\/output\.css" rel="stylesheet">/g,
                    `<style>${cssContent}</style>`
                );
                
                // Remove Google Fonts dependencies for offline use
                htmlContent = htmlContent.replace(
                    /<link href="https:\/\/fonts\.googleapis\.com\/css2\?family=Inter[^"]*" rel="stylesheet">/g,
                    ''
                );
                
                htmlContent = htmlContent.replace(
                    /<link href="https:\/\/fonts\.googleapis\.com\/css2\?family=JetBrains\+Mono[^"]*" rel="stylesheet">/g,
                    ''
                );
                
                // Add inline CSS to override font families with system fonts
                const fontOverrideCSS = `
                    <style>
                        body, html {
                            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif !important;
                        }
                        code, kbd, pre, samp, .font-mono {
                            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace !important;
                        }
                    </style>
                `;
                
                // Insert the font override CSS after the main CSS
                htmlContent = htmlContent.replace(
                    /<\/style>/,
                    `</style>${fontOverrideCSS}`
                );
                
                // Create a blob with the HTML content
                const blob = new Blob([htmlContent], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                
                // Create a download link
                const a = document.createElement('a');
                a.href = url;
                a.download = `risk-analysis-${selectedAccount}-${new Date().toISOString().split('T')[0]}.html`;
                a.click();
                
                // Clean up
                URL.revokeObjectURL(url);
                
            } catch (error) {
                console.error('Error downloading HTML:', error);
                alert('Error downloading HTML file. Please try again.');
            }
        }

        // Event listeners
        function initEventListeners() {
            // Account selector
            document.getElementById('account-selector').addEventListener('change', async (event) => {
                const selectedAcctno = event.target.value;
                if (selectedAcctno) {
                    await loadAccountData(selectedAcctno);
                } else {
                    // Clear data when no account is selected
                    apiData = {};
                    selectedAccount = null;
                    // Update account status
                    updateAccountStatus();
                    // Update horizontal tabs
                    await createHorizontalTabs();
                    // Clear content containers
                    document.querySelectorAll('.section-content').forEach(section => {
                        const contentContainer = section.querySelector('[id$="-content"]');
                        if (contentContainer) {
                            contentContainer.innerHTML = `
                                <div class="text-center py-8 text-gray-500">
                                    <i data-lucide="user" class="w-12 h-12 mx-auto mb-3 text-gray-300"></i>
                                    <p>Please select an account to view analysis data</p>
                                </div>
                            `;
                        }
                    });
                    createIcons();
                }
            });
            
            // Mobile menu
            document.getElementById('mobile-menu-toggle').addEventListener('click', () => toggleMobileMenu());
            document.getElementById('mobile-overlay').addEventListener('click', () => toggleMobileMenu(false));
            
            // Refresh button
            document.getElementById('refresh-btn').addEventListener('click', async () => {
                if (selectedAccount) {
                    await loadAccountData(selectedAccount);
                } else {
                    await initDashboard();
                }
            });
            
            // Export button
            document.getElementById('export-btn').addEventListener('click', () => {
                if (!selectedAccount) {
                    alert('Please select an account first');
                    return;
                }
                const data = { 
                    account: selectedAccount,
                    section: currentSection, 
                    timestamp: new Date().toISOString(), 
                    data: apiData 
                };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `risk-analysis-${selectedAccount}-${currentSection}-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
            });
            
            // Download HTML button
            document.getElementById('download-html-btn').addEventListener('click', () => {
                downloadHTML();
            });
            
            // Show full graph radio buttons - will be set up when the radio buttons are created
            setupShowFullGraphCheckbox();
        }

        // Handle graph view radio button change
        async function handleShowFullGraphChange(event) {
            console.log('Graph view changed to:', event.target.value);
            
            // Re-render the graph with the new setting
            const selectedValue = event.target.value;
            
            // Re-render using the network graph for all view modes
            if (apiData.graph && apiData.graph.nodes && apiData.graph.nodes.length > 0) {
                await renderNetworkGraph();
            } else {
                console.warn('No graph data available for rendering');
            }
        }

        // Handle degree dropdown change
        async function handleDegreeChange(event) {
            console.log('Subgraph degree changed to:', event.target.value);
            
            // Only re-render if subgraph is currently selected
            const subgraphRadio = document.getElementById('show-subgraph');
            if (subgraphRadio && subgraphRadio.checked) {
                if (apiData.graph && apiData.graph.nodes && apiData.graph.nodes.length > 0) {
                    await renderNetworkGraph();
                } else {
                    console.warn('No graph data available for rendering');
                }
            }
        }

        // Set up graph view radio buttons event listener
        function setupShowFullGraphCheckbox() {
            const fullGraphRadio = document.getElementById('show-full-graph');
            const subgraphRadio = document.getElementById('show-subgraph');
            const treeRadio = document.getElementById('show-tree');
            const degreeDropdown = document.getElementById('subgraph-degree');
            
            if (fullGraphRadio && subgraphRadio && treeRadio) {
                // Remove any existing event listeners to avoid duplicates
                fullGraphRadio.removeEventListener('change', handleShowFullGraphChange);
                subgraphRadio.removeEventListener('change', handleShowFullGraphChange);
                treeRadio.removeEventListener('change', handleShowFullGraphChange);
                
                // Add event listeners to all radio buttons
                fullGraphRadio.addEventListener('change', handleShowFullGraphChange);
                subgraphRadio.addEventListener('change', handleShowFullGraphChange);
                treeRadio.addEventListener('change', handleShowFullGraphChange);
                
                console.log('Graph view radio buttons event listeners set up');
            } else {
                console.warn('Graph view radio buttons not found, will retry when content is created');
            }
            
            // Set up degree dropdown listener
            if (degreeDropdown) {
                degreeDropdown.removeEventListener('change', handleDegreeChange);
                degreeDropdown.addEventListener('change', handleDegreeChange);
                console.log('Degree dropdown event listener set up');
            } else {
                console.warn('Degree dropdown not found');
            }
        }

        // Error handling
        function showError(message) {
            const container = document.getElementById('content-container');
            container.innerHTML = `
                <div class="text-center py-16">
                    <div class="w-20 h-20 bg-danger-100 rounded-2xl flex items-center justify-center mx-auto mb-6">
                        <i data-lucide="alert-circle" class="w-10 h-10 text-danger-600"></i>
                    </div>
                    <h3 class="text-xl font-semibold text-gray-900 mb-4">Error Loading Data</h3>
                    <p class="text-gray-600 mb-6">${message}</p>
                    <button onclick="initDashboard()" class="px-6 py-3 bg-primary-500 text-white rounded-xl hover:bg-primary-600 transition-colors">
                        Try Again
                            </button>
                        </div>
                    `;
                createIcons();
        }

        // Global event listener for table sorting
        document.addEventListener('click', (event) => {
            try {
                const sortableHeader = event.target.closest('th[data-sortable]');
                if (sortableHeader) {
                    const table = sortableHeader.closest('table');
                    if (!table || !table.id) {
                        console.warn('Table not found or missing ID for sortable header');
                        return;
                    }
                    
                    const tableId = table.id;
                    const columnIndex = Array.from(sortableHeader.parentNode.children).indexOf(sortableHeader) + 1;
                    
                    if (columnIndex <= 0) {
                        console.warn('Invalid column index:', columnIndex);
                        return;
                    }
                    
                    sortTable(tableId, columnIndex, sortableHeader);
                }
            } catch (error) {
                console.error('Error in table sorting event listener:', error);
            }
        });

        // Modal event listeners
        document.addEventListener('DOMContentLoaded', function() {
            // Close modal when clicking the X button
            const closeBtn = document.getElementById('close-transaction-detail-modal');
            const modal = document.getElementById('transaction-detail-modal');
            
            if (closeBtn) {
                closeBtn.addEventListener('click', function() {
                    modal.classList.add('hidden');
                });
            }
            
            // Close modal when clicking outside the modal content
            if (modal) {
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        modal.classList.add('hidden');
                    }
                });
            }
            
            // Close modal with Escape key
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && !modal.classList.contains('hidden')) {
                    modal.classList.add('hidden');
                }
            });
        });

        // Initialize the dashboard when page loads
        document.addEventListener('DOMContentLoaded', initDashboard);

        // Create horizontal tabs navigation
        async function createHorizontalTabs() {
            const tabContainer = document.getElementById('horizontal-tab-container');
            
            // Get current selected account and URL param for active tab
            const currentAccount = selectedAccount || '';
            const urlParams = new URLSearchParams(window.location.search);
            const accountFromUrl = urlParams.get('account') || '';
            const activeAccount = accountFromUrl || currentAccount;
            
            if (!currentAccount && !accountFromUrl) {
                // If no account selected, show placeholder
                tabContainer.innerHTML = `
                    <div class="text-xs text-gray-500 italic px-2">
                        Select an account to view related analysis
                    </div>
                `;
                return;
            }
            
            try {
                console.log('Creating horizontal tabs for account:', currentAccount);

                // Extract search string in format "RM-xxxx_NM-xxxx" or "ACCT-xxxx_NM-xxxx" from selected account
                let searchString = '';
                
                // Check if account matches pattern with RM- and NM-
                const rmMatch = currentAccount.match(/RM-[^_]+/);
                const nmMatch = currentAccount.match(/NM-[^_]+/);
                const acctMatch = currentAccount.match(/ACCT-[^_]+/);
                

                if (rmMatch && nmMatch) {
                    searchString = `${rmMatch[0]}_${nmMatch[0]}`;
                } else if (acctMatch && nmMatch) {
                    searchString = `${acctMatch[0]}_${nmMatch[0]}`;
                } else if (rmMatch) {
                    searchString = rmMatch[0];
                } else if (acctMatch) {
                    searchString = acctMatch[0];
                } else {
                    // Fallback to using the account as-is
                    searchString = currentAccount.split('_')[0];
                }
                
                console.log(`Searching for accounts with: ${searchString}`);
                
                // Fetch related accounts from API
                const response = await fetch(`/api/accounts?search=${encodeURIComponent(searchString)}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                let accounts = data.accounts || [];
                
                console.log(`Found ${accounts.length} related accounts:`, accounts);
                
                if (accounts.length === 0) {
                    tabContainer.innerHTML = `
                        <div class="text-xs text-gray-500 italic px-2">
                            No related analysis found
                        </div>
                    `;
                    return;
                }
                
                // Sort accounts: Summary first, then others
                accounts.sort((a, b) => {
                    const aIsSummary = a.includes('Summary') || a.includes('summary');
                    const bIsSummary = b.includes('Summary') || b.includes('summary');
                    
                    if (aIsSummary && !bIsSummary) return -1;
                    if (!aIsSummary && bIsSummary) return 1;
                    return 0; // Keep original order for non-summary items
                });
                
                console.log('Sorted accounts (Summary first):', accounts);
                
                // Create tabs for each account
                const tabsHTML = accounts.map(acct => {
                    const isActive = acct === activeAccount;
                    
                    // Extract display name - prioritize IND- part
                    let displayName = acct;
                    
                    // Try to extract industry from IND- prefix
                    const indMatch = acct.match(/IND-([^_\.]+)/);
                    if (indMatch) {
                        // Extract and clean up the industry name
                        displayName = indMatch[1]
                            .replace(/-/g, ' ')
                            .replace(/_/g, ' ')
                            .split(' ')
                            .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                            .join(' ');
                    } else if (acct.includes('Summary') || acct.includes('summary')) {
                        displayName = 'Summary';
                    } else {
                        // Use last part after underscore
                        const parts = acct.split('_');
                        displayName = parts[parts.length - 1].replace(/-/g, ' ');
                    }
                    
                    // Limit display name length
                    if (displayName.length > 25) {
                        displayName = displayName.substring(0, 22) + '...';
                    }
                    
                    return `
                        <button 
                            class="horizontal-tab ${isActive ? 'active' : ''}"
                            onclick="loadAccountFromTab('${acct.replace(/'/g, "\\'")}')"
                            title="${acct}"
                        >
                            <i data-lucide="file-text" class="tab-icon"></i>
                            <span>${displayName}</span>
                        </button>
                    `;
                }).join('');
                
                tabContainer.innerHTML = tabsHTML;
                createIcons();
                
            } catch (error) {
                console.error('Error creating horizontal tabs:', error);
                tabContainer.innerHTML = `
                    <div class="text-xs text-gray-500 italic px-2">
                        Error loading related accounts
                    </div>
                `;
            }
        }
        
        // Load account data when clicking a horizontal tab
        async function loadAccountFromTab(acctno) {
            if (!acctno) return;
            
            console.log(`Loading account from tab: ${acctno}`);
            
            // Update the dropdown selector
            const accountSelector = document.getElementById('account-selector');
            accountSelector.value = acctno;
            
            // Load the account data
            await loadAccountData(acctno);
            
            // Recreate horizontal tabs to update active state
            await createHorizontalTabs();
        }
    </script>

    <!-- Transaction Usage Detail Popup Modal -->
    <div id="transaction-detail-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center p-4">
        <div class="bg-white rounded-lg shadow-xl max-w-3xl w-1/2 max-h-[90vh] overflow-hidden">
            <div class="flex justify-between items-center p-4 border-b border-gray-200">
                <h3 class="text-lg font-semibold text-gray-900">Transaction Usage Detail</h3>
                <button id="close-transaction-detail-modal" class="text-gray-400 hover:text-gray-600">
                    <i data-lucide="x" class="w-6 h-6"></i>
                </button>
            </div>
            <div class="p-4 overflow-y-auto max-h-[calc(90vh-120px)] modal-scrollbar">
                <div id="transaction-detail-content">
                    <div class="text-center py-8">
                        <i data-lucide="loader" class="w-8 h-8 mx-auto mb-2 animate-spin text-gray-400"></i>
                        <p class="text-gray-500">Loading transaction details...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>
